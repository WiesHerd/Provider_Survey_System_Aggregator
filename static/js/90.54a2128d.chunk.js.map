{"version":3,"file":"static/js/90.54a2128d.chunk.js","mappings":"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","sources":["services/SpecialtyMappingService.ts","services/BackendService.ts"],"sourcesContent":["import { ISpecialtyMapping, ISourceSpecialty, IUnmappedSpecialty, IAutoMappingConfig, ISurveyData, ISpecialtyGroup, IMappingSuggestion } from '../types/specialty';\r\nimport { stringSimilarity } from 'string-similarity-js';\r\nimport { LocalStorageService } from './StorageService';\r\nimport BackendService from './BackendService';\r\nimport { ISurveyRow } from '../types/survey';\r\n\r\nexport class SpecialtyMappingService {\r\n  private readonly MAPPINGS_KEY = 'specialty-mappings';\r\n  private readonly storageService: LocalStorageService;\r\n  private readonly GROUPS_KEY = 'specialty_groups';\r\n  private readonly LEARNED_MAPPINGS_KEY = 'learned-specialty-mappings';\r\n  \r\n  // Add caching for performance\r\n  private specialtyCache = new Map<string, Set<string>>();\r\n  private cacheExpiry = new Map<string, number>();\r\n  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes\r\n\r\n  private readonly SYNONYMS: Record<string, string[]> = {\r\n    'cardiology': ['heart', 'cardiac', 'cardiovascular'],\r\n    'orthopedics': ['ortho', 'orthopedic', 'orthopaedic'],\r\n    'pediatrics': ['peds', 'pediatric', 'children'],\r\n    'critical care': [\r\n      'intensivist', \r\n      'critical care medicine', \r\n      'critical care/intensivist', \r\n      'intensive care',\r\n      'critical care medicine',\r\n      'cc medicine',\r\n      'cc/intensivist',\r\n      'icu'\r\n    ],\r\n    'emergency medicine': ['emergency', 'er', 'ed'],\r\n    'internal medicine': ['internist', 'internal med'],\r\n    'obstetrics': ['ob/gyn', 'obgyn', 'obstetrics and gynecology', 'obstetrics & gynecology'],\r\n    'anesthesiology': ['anesthesia', 'anesthetist'],\r\n    'family medicine': ['family practice', 'family physician', 'family med'],\r\n    'neurology': ['neurological', 'neuro'],\r\n    'psychiatry': ['psychiatric', 'mental health'],\r\n    'radiology': ['radiologist', 'imaging', 'diagnostic radiology'],\r\n    'surgery': ['surgeon', 'surgical']\r\n  };\r\n\r\n  constructor(storageService: LocalStorageService) {\r\n    this.storageService = storageService;\r\n  }\r\n\r\n  async saveMapping(mapping: ISpecialtyMapping): Promise<void> {\r\n    // Persist to backend API\r\n    const payload = {\r\n      standardizedName: mapping.standardizedName,\r\n      sourceSpecialties: mapping.sourceSpecialties.map(s => ({\r\n        specialty: s.specialty,\r\n        originalName: s.originalName,\r\n        surveySource: s.surveySource\r\n      }))\r\n    };\r\n    await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:3001/api'}/mappings/specialty`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify(payload)\r\n    });\r\n  }\r\n\r\n  async getAllMappings(): Promise<ISpecialtyMapping[]> {\r\n    try {\r\n      const res = await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:3001/api'}/mappings/specialty`);\r\n      if (!res.ok) throw new Error('Failed to fetch');\r\n      const data = await res.json();\r\n      return data as ISpecialtyMapping[];\r\n    } catch (error) {\r\n      console.error('Error fetching specialty mappings:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getUnmappedSpecialties(): Promise<IUnmappedSpecialty[]> {\r\n    try {\r\n      console.log('🔄 Fetching unmapped specialties with caching...');\r\n      \r\n      // Get all surveys from backend\r\n      const backendService = BackendService.getInstance();\r\n      console.log('📡 Calling backendService.getAllSurveys()...');\r\n      const surveys = await backendService.getAllSurveys();\r\n      console.log('📊 Surveys received:', surveys.length, surveys);\r\n      \r\n      const mappings = await this.getAllMappings();\r\n      console.log('🗺️ Existing mappings:', mappings.length);\r\n      \r\n      const unmappedSpecialties: IUnmappedSpecialty[] = [];\r\n      const mappedNames = new Set<string>();\r\n\r\n      // Collect all mapped specialty names (both standardized and original names)\r\n      mappings.forEach(mapping => {\r\n        mappedNames.add(mapping.standardizedName.toLowerCase());\r\n        mapping.sourceSpecialties.forEach((source: ISourceSpecialty) => {\r\n          mappedNames.add(source.specialty.toLowerCase());\r\n        });\r\n      });\r\n      console.log('✅ Mapped names collected:', Array.from(mappedNames));\r\n\r\n      // Process surveys in batches for better performance\r\n      const batchSize = 10;\r\n\r\n      for (let i = 0; i < surveys.length; i += batchSize) {\r\n        const batch = surveys.slice(i, i + batchSize);\r\n        console.log(`📦 Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(surveys.length / batchSize)}`);\r\n        \r\n        const batchPromises = batch.map(async (survey) => {\r\n          try {\r\n            // Fetch from backend\r\n            console.log(`🔍 Fetching data for survey ${survey.id}...`);\r\n            const { rows } = await backendService.getSurveyData(survey.id, {}, { page: 1, limit: 10000 });\r\n            console.log(`📋 Survey ${survey.id} returned ${rows.length} rows`);\r\n            \r\n            // Extract specialties and count per survey\r\n            const counts = new Map<string, number>();\r\n            \r\n            rows.forEach((row: any, index: number) => {\r\n              // Log all column names from first row\r\n              if (index === 0) {\r\n                console.log('📋 All column names in row:', Object.keys(row));\r\n              }\r\n              \r\n              // Check multiple possible specialty column names\r\n              const possibleSpecialtyColumns = [\r\n                'specialty', 'Specialty', 'Provider Type', 'provider_type', \r\n                'ProviderType', 'specialty_name', 'SpecialtyName', 'specialtyName',\r\n                'PROVIDER_TYPE', 'SPECIALTY', 'Specialty Type', 'specialty_type'\r\n              ];\r\n              \r\n              let specialty = '';\r\n              for (const colName of possibleSpecialtyColumns) {\r\n                if (row[colName] && typeof row[colName] === 'string' && row[colName].trim()) {\r\n                  specialty = row[colName].trim();\r\n                  console.log(`✅ Found specialty in column \"${colName}\": ${specialty}`);\r\n                  break;\r\n                }\r\n              }\r\n              \r\n              if (specialty) {\r\n                const key = specialty;\r\n                counts.set(key, (counts.get(key) || 0) + 1);\r\n              }\r\n              \r\n              // Log first few rows for debugging\r\n              if (index < 5) {\r\n                console.log(`Row ${index}:`, { specialty, row });\r\n              }\r\n            });\r\n\r\n            console.log(`🏥 Found specialties in survey ${survey.id}:`, Array.from(counts.entries()));\r\n\r\n            const surveySource = (survey as any).type || (survey as any).surveyProvider || 'Unknown';\r\n            return { surveySource, counts };\r\n          } catch (error) {\r\n            console.error(`❌ Error processing survey ${survey.id}:`, error);\r\n            return { surveySource: 'Unknown', counts: new Map<string, number>() };\r\n          }\r\n        });\r\n\r\n        const batchResults = await Promise.all(batchPromises);\r\n        \r\n        // Convert per-survey counts into unmapped entries (one per survey source)\r\n        batchResults.forEach(({ surveySource, counts }) => {\r\n                      counts.forEach((count, specialty) => {\r\n              const key = specialty.toLowerCase();\r\n              if (!mappedNames.has(key)) {\r\n                unmappedSpecialties.push({\r\n                  id: `${surveySource}-${specialty}`,\r\n                  name: specialty,\r\n                  surveySource,\r\n                  frequency: count\r\n                });\r\n              }\r\n            });\r\n        });\r\n      }\r\n\r\n      console.log(`✅ Found ${unmappedSpecialties.length} unmapped specialties:`, unmappedSpecialties);\r\n      return unmappedSpecialties;\r\n    } catch (error) {\r\n      console.error('❌ Error getting unmapped specialties:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async autoMapSpecialties(config: IAutoMappingConfig): Promise<ISpecialtyMapping[]> {\r\n    console.log('🚀 Starting auto-mapping with retry logic...');\r\n    \r\n    const unmapped = await this.getUnmappedSpecialties();\r\n    const existingMappings = await this.getAllMappings();\r\n    const newMappings: ISpecialtyMapping[] = [];\r\n    const failedMappings: Array<{ specialty: string; error: string }> = [];\r\n\r\n    // Process in batches with retry logic\r\n    const batchSize = 50;\r\n    const batches = [];\r\n    \r\n    for (let i = 0; i < unmapped.length; i += batchSize) {\r\n      batches.push(unmapped.slice(i, i + batchSize));\r\n    }\r\n\r\n    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {\r\n      const batch = batches[batchIndex];\r\n      console.log(`📦 Processing auto-mapping batch ${batchIndex + 1}/${batches.length}`);\r\n      \r\n      const batchPromises = batch.map(async (specialty) => {\r\n        return this.processSpecialtyWithRetry(specialty, existingMappings, config, 3);\r\n      });\r\n\r\n      const batchResults = await Promise.allSettled(batchPromises);\r\n      \r\n      batchResults.forEach((result, index) => {\r\n        const specialty = batch[index];\r\n        if (result.status === 'fulfilled' && result.value) {\r\n          newMappings.push(result.value);\r\n        } else {\r\n          failedMappings.push({\r\n            specialty: specialty.name,\r\n            error: result.status === 'rejected' ? result.reason?.message || 'Unknown error' : 'Failed to process'\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    console.log(`✅ Auto-mapping completed: ${newMappings.length} successful, ${failedMappings.length} failed`);\r\n    \r\n    if (failedMappings.length > 0) {\r\n      console.warn('⚠️ Failed mappings:', failedMappings);\r\n    }\r\n\r\n    return newMappings;\r\n  }\r\n\r\n  private async processSpecialtyWithRetry(\r\n    specialty: IUnmappedSpecialty,\r\n    existingMappings: ISpecialtyMapping[],\r\n    config: IAutoMappingConfig,\r\n    maxRetries: number\r\n  ): Promise<ISpecialtyMapping | null> {\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        const bestMatch = this.findBestMatch(specialty.name, existingMappings, config);\r\n\r\n        if (bestMatch && bestMatch.confidence >= config.confidenceThreshold) {\r\n          const mapping = existingMappings.find(m => m.standardizedName === bestMatch.standardizedName);\r\n          if (mapping) {\r\n            mapping.sourceSpecialties.push({\r\n              id: crypto.randomUUID(),\r\n              specialty: specialty.name,\r\n              originalName: specialty.name,\r\n              surveySource: specialty.surveySource,\r\n              mappingId: mapping.id\r\n            });\r\n            await this.saveMapping(mapping);\r\n            return mapping;\r\n          }\r\n        }\r\n        return null; // No match found, not an error\r\n      } catch (error) {\r\n        console.error(`Attempt ${attempt} failed for specialty ${specialty.name}:`, error);\r\n        if (attempt === maxRetries) {\r\n          throw error;\r\n        }\r\n        // Wait before retry (exponential backoff)\r\n        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private findSuggestedMatches(\r\n    specialty: string,\r\n    existingMappings: ISpecialtyMapping[]\r\n  ): Array<{ standardizedName: string; confidence: number }> {\r\n    return existingMappings\r\n      .map(mapping => ({\r\n        standardizedName: mapping.standardizedName,\r\n        confidence: this.calculateConfidence(specialty, mapping)\r\n      }))\r\n      .filter(match => match.confidence > 0.3)\r\n      .sort((a, b) => b.confidence - a.confidence)\r\n      .slice(0, 5);\r\n  }\r\n\r\n  private findBestMatch(\r\n    specialty: string,\r\n    existingMappings: ISpecialtyMapping[],\r\n    config: IAutoMappingConfig\r\n  ): { standardizedName: string; confidence: number } | null {\r\n    const matches = existingMappings\r\n      .map(mapping => ({\r\n        standardizedName: mapping.standardizedName,\r\n        confidence: this.calculateConfidence(\r\n          specialty,\r\n          mapping,\r\n          config.useFuzzyMatching,\r\n          true\r\n        )\r\n      }))\r\n      .filter(match => match.confidence >= config.confidenceThreshold)\r\n      .sort((a, b) => b.confidence - a.confidence);\r\n\r\n    return matches[0] || null;\r\n  }\r\n\r\n  private calculateConfidence(\r\n    specialty: string,\r\n    mapping: ISpecialtyMapping,\r\n    useFuzzyMatching: boolean = true,\r\n    useSynonyms: boolean = true\r\n  ): number {\r\n    let maxConfidence = 0;\r\n    const specialtyLower = specialty.toLowerCase();\r\n    const standardizedLower = mapping.standardizedName.toLowerCase();\r\n\r\n    // Check learned mappings first\r\n    this.getLearnedMapping(specialty).then(learnedMapping => {\r\n      if (learnedMapping && learnedMapping === mapping.standardizedName) {\r\n        return 1.0;\r\n      }\r\n    });\r\n\r\n    // Direct match check\r\n    if (specialtyLower === standardizedLower) {\r\n      return 1.0;\r\n    }\r\n\r\n    // Critical Care specific matching\r\n    if (specialtyLower.includes('critical care') || \r\n        specialtyLower.includes('intensivist') || \r\n        standardizedLower.includes('critical care') || \r\n        standardizedLower.includes('intensivist')) {\r\n      // If both terms are related to critical care, give very high confidence\r\n      if ((specialtyLower.includes('critical care') || specialtyLower.includes('intensivist')) &&\r\n          (standardizedLower.includes('critical care') || standardizedLower.includes('intensivist'))) {\r\n        return 0.95; // Very high confidence for critical care variations\r\n      }\r\n    }\r\n\r\n    // Synonym check\r\n    if (useSynonyms) {\r\n      for (const [key, synonyms] of Object.entries(this.SYNONYMS)) {\r\n        const isSpecialtyMatch = specialtyLower.includes(key) || \r\n          synonyms.some(syn => specialtyLower.includes(syn));\r\n        const isStandardizedMatch = standardizedLower.includes(key) || \r\n          synonyms.some(syn => standardizedLower.includes(syn));\r\n        \r\n        if (isSpecialtyMatch && isStandardizedMatch) {\r\n          maxConfidence = Math.max(maxConfidence, 0.9);\r\n        }\r\n      }\r\n    }\r\n\r\n    // String similarity check\r\n    if (useFuzzyMatching) {\r\n      const similarity = stringSimilarity(specialtyLower, standardizedLower);\r\n      maxConfidence = Math.max(maxConfidence, similarity);\r\n\r\n      // Check against all source names\r\n      for (const source of mapping.sourceSpecialties) {\r\n        const sourceLower = source.specialty.toLowerCase();\r\n        \r\n        // Direct match with source\r\n        if (specialtyLower === sourceLower) {\r\n          return 1.0;\r\n        }\r\n        \r\n        const sourceSimilarity = stringSimilarity(specialtyLower, sourceLower);\r\n        maxConfidence = Math.max(maxConfidence, sourceSimilarity);\r\n\r\n        // Additional check for partial matches\r\n        if (specialtyLower.includes(sourceLower) || sourceLower.includes(specialtyLower)) {\r\n          maxConfidence = Math.max(maxConfidence, 0.85);\r\n        }\r\n      }\r\n    }\r\n\r\n    return maxConfidence;\r\n  }\r\n\r\n  // Group management methods\r\n  async saveGroup(group: ISpecialtyGroup): Promise<void> {\r\n    const groups = await this.getAllGroups();\r\n    const existingIndex = groups.findIndex(g => g.id === group.id);\r\n    \r\n    if (existingIndex >= 0) {\r\n      groups[existingIndex] = {\r\n        ...group,\r\n        updatedAt: new Date()\r\n      };\r\n    } else {\r\n      const now = new Date();\r\n      groups.push({\r\n        ...group,\r\n        createdAt: now,\r\n        updatedAt: now\r\n      });\r\n    }\r\n\r\n    await this.storageService.storeSurveyData<ISpecialtyGroup>({\r\n      id: this.GROUPS_KEY,\r\n      metadata: { \r\n        type: 'specialty_groups',\r\n        totalRows: groups.length,\r\n        uniqueSpecialties: [],\r\n        uniqueProviderTypes: [],\r\n        uniqueRegions: [],\r\n        columnMappings: {}\r\n      },\r\n      rows: groups\r\n    });\r\n  }\r\n\r\n  async getAllGroups(): Promise<ISpecialtyGroup[]> {\r\n    try {\r\n      const result = await this.storageService.getSurveyData<ISpecialtyGroup>(this.GROUPS_KEY);\r\n      return result.rows;\r\n    } catch {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async deleteGroup(groupId: string): Promise<void> {\r\n    const groups = await this.getAllGroups();\r\n    const filteredGroups = groups.filter(g => g.id !== groupId);\r\n    \r\n    await this.storageService.storeSurveyData<ISpecialtyGroup>({\r\n      id: this.GROUPS_KEY,\r\n      metadata: { \r\n        type: 'specialty_groups',\r\n        totalRows: filteredGroups.length,\r\n        uniqueSpecialties: [],\r\n        uniqueProviderTypes: [],\r\n        uniqueRegions: [],\r\n        columnMappings: {}\r\n      },\r\n      rows: filteredGroups\r\n    });\r\n  }\r\n\r\n  async getMappings(): Promise<ISpecialtyMapping[]> {\r\n    try {\r\n      const mappings = await this.storageService.getItem(this.MAPPINGS_KEY) as ISpecialtyMapping[];\r\n      return mappings || [];\r\n    } catch (error) {\r\n      console.error('Error fetching specialty mappings:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async createMapping(standardizedName: string, sourceSpecialties: ISourceSpecialty[]): Promise<ISpecialtyMapping> {\r\n    const mapping: ISpecialtyMapping = {\r\n      id: crypto.randomUUID(),\r\n      standardizedName,\r\n      sourceSpecialties: sourceSpecialties.map(s => ({\r\n        ...s,\r\n        mappingId: crypto.randomUUID()\r\n      })),\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n\r\n    // Learn from new mappings\r\n    for (const specialty of sourceSpecialties) {\r\n      if (specialty.specialty !== standardizedName) {\r\n        await this.saveLearningData(specialty.specialty, standardizedName);\r\n      }\r\n    }\r\n\r\n    await this.saveMapping(mapping);\r\n    return mapping;\r\n  }\r\n\r\n  async updateMapping(mappingId: string, updates: Partial<ISpecialtyMapping>): Promise<ISpecialtyMapping> {\r\n    const mappings = await this.getMappings();\r\n    const index = mappings.findIndex(m => m.id === mappingId);\r\n    \r\n    if (index === -1) {\r\n      throw new Error(`Mapping with id ${mappingId} not found`);\r\n    }\r\n\r\n    // Learn from this correction\r\n    if (updates.standardizedName && updates.standardizedName !== mappings[index].standardizedName) {\r\n      await this.saveLearningData(mappings[index].standardizedName, updates.standardizedName);\r\n    }\r\n\r\n    const updatedMapping = {\r\n      ...mappings[index],\r\n      ...updates,\r\n      updatedAt: new Date()\r\n    };\r\n\r\n    // Update via backend API\r\n    await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:3001/api'}/mappings/specialty/${mappingId}`, {\r\n      method: 'PUT',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify(updatedMapping)\r\n    });\r\n\r\n    return updatedMapping;\r\n  }\r\n\r\n  async deleteMapping(mappingId: string): Promise<void> {\r\n    // Delete via backend API\r\n    await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:3001/api'}/mappings/specialty/${mappingId}`, {\r\n      method: 'DELETE'\r\n    });\r\n  }\r\n\r\n  async clearAllMappings(): Promise<void> {\r\n    // Clear via backend API\r\n    await fetch(`${process.env.REACT_APP_API_URL || 'http://localhost:3001/api'}/mappings/specialty`, {\r\n      method: 'DELETE'\r\n    });\r\n    await this.storageService.setItem(this.LEARNED_MAPPINGS_KEY, {});\r\n  }\r\n\r\n  async suggestMappings(specialty: IUnmappedSpecialty, config: IAutoMappingConfig): Promise<ISpecialtyMapping[]> {\r\n    const mappings = await this.getMappings();\r\n    const suggestions: Array<{ mapping: ISpecialtyMapping; similarity: number }> = [];\r\n\r\n    for (const mapping of mappings) {\r\n      let maxSimilarity = 0;\r\n\r\n      // Compare with standardized name\r\n      const standardizedSimilarity = this.calculateSimilarity(\r\n        specialty.name,\r\n        mapping.standardizedName,\r\n        config\r\n      );\r\n      maxSimilarity = Math.max(maxSimilarity, standardizedSimilarity);\r\n\r\n      // Compare with source specialties\r\n      for (const source of mapping.sourceSpecialties) {\r\n        const sourceSimilarity = this.calculateSimilarity(\r\n          specialty.name,\r\n          source.specialty,\r\n          config\r\n        );\r\n        maxSimilarity = Math.max(maxSimilarity, sourceSimilarity);\r\n      }\r\n\r\n      if (maxSimilarity >= config.confidenceThreshold) {\r\n        suggestions.push({ mapping, similarity: maxSimilarity });\r\n      }\r\n    }\r\n\r\n    return suggestions\r\n      .sort((a, b) => b.similarity - a.similarity)\r\n      .map(suggestion => suggestion.mapping);\r\n  }\r\n\r\n  private calculateSimilarity(str1: string, str2: string, config: IAutoMappingConfig): number {\r\n    // Always case-insensitive comparison\r\n    str1 = str1.toLowerCase();\r\n    str2 = str2.toLowerCase();\r\n\r\n    if (str1 === str2) return 1;\r\n    if (!config.useFuzzyMatching) return 0;\r\n\r\n    return stringSimilarity(str1, str2);\r\n  }\r\n\r\n  async createGroup(standardizedName: string, selectedSpecialties: IUnmappedSpecialty[]): Promise<ISpecialtyGroup> {\r\n    const now = new Date();\r\n    const group: ISpecialtyGroup = {\r\n      id: `${standardizedName}`.toLowerCase().replace(/\\s+/g, '-'),\r\n      standardizedName,\r\n      selectedSpecialties,\r\n      createdAt: now,\r\n      updatedAt: now\r\n    };\r\n    \r\n    await this.saveGroup(group);\r\n    return group;\r\n  }\r\n\r\n  async generateMappingSuggestions(config: IAutoMappingConfig): Promise<IMappingSuggestion[]> {\r\n    const unmappedSpecialties = await this.getUnmappedSpecialties();\r\n    const existingMappings = config.useExistingMappings ? await this.getAllMappings() : [];\r\n    const suggestions: IMappingSuggestion[] = [];\r\n\r\n    // Group specialties by similar names\r\n    const groups = new Map<string, Array<{ name: string; surveySource: string }>>();\r\n\r\n    // Helper function to normalize strings for comparison\r\n    const normalizeString = (str: string): string => {\r\n      let normalized = str.toLowerCase();\r\n      if (!config.useFuzzyMatching) {\r\n        // Only basic normalization if fuzzy matching is disabled\r\n        return normalized.trim();\r\n      }\r\n      // More aggressive normalization for fuzzy matching\r\n      normalized = normalized\r\n        .replace(/[^a-z0-9\\s]/g, '') // Remove special characters\r\n        .replace(/\\s+/g, ' ') // Normalize whitespace\r\n        .trim();\r\n      return normalized;\r\n    };\r\n\r\n    // Function to calculate similarity between two strings\r\n    const calculateSimilarity = (str1: string, str2: string): number => {\r\n      const normalized1 = normalizeString(str1);\r\n      const normalized2 = normalizeString(str2);\r\n      \r\n      if (!config.useFuzzyMatching) {\r\n        // Exact match when fuzzy matching is disabled\r\n        return normalized1 === normalized2 ? 1 : 0;\r\n      }\r\n      \r\n      return stringSimilarity(normalized1, normalized2);\r\n    };\r\n\r\n    // First pass: group by exact matches\r\n    unmappedSpecialties.forEach(specialty => {\r\n      let foundMatch = false;\r\n      \r\n      // Check against existing mappings first\r\n      if (config.useExistingMappings) {\r\n        for (const mapping of existingMappings) {\r\n          const similarity = calculateSimilarity(specialty.name, mapping.standardizedName);\r\n          if (similarity >= config.confidenceThreshold) {\r\n            const key = mapping.standardizedName;\r\n            const group = groups.get(key) || [];\r\n            group.push({ name: specialty.name, surveySource: specialty.surveySource as any });\r\n            groups.set(key, group);\r\n            foundMatch = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!foundMatch) {\r\n        // Try to match with other unmapped specialties\r\n        let matched = false;\r\n        // Convert Map.entries() to Array to avoid iterator issues\r\n        Array.from(groups.entries()).forEach(([key, group]) => {\r\n          if (!matched) {\r\n            const similarity = calculateSimilarity(specialty.name, key);\r\n            if (similarity >= config.confidenceThreshold) {\r\n              group.push({ name: specialty.name, surveySource: specialty.surveySource as any });\r\n              matched = true;\r\n            }\r\n          }\r\n        });\r\n\r\n        if (!matched) {\r\n          // Create new group\r\n          groups.set(specialty.name, [{ name: specialty.name, surveySource: specialty.surveySource as any }]);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Convert groups to suggestions\r\n    // Convert Map.entries() to Array to avoid iterator issues\r\n    Array.from(groups.entries()).forEach(([standardizedName, specialties]) => {\r\n      if (specialties.length > 0) {\r\n        // Calculate average confidence for the group\r\n        let totalConfidence = 0;\r\n        let comparisons = 0;\r\n\r\n        for (let i = 0; i < specialties.length; i++) {\r\n          for (let j = i + 1; j < specialties.length; j++) {\r\n            totalConfidence += calculateSimilarity(specialties[i].name, specialties[j].name);\r\n            comparisons++;\r\n          }\r\n        }\r\n\r\n        const confidence = comparisons > 0 \r\n          ? totalConfidence / comparisons \r\n          : (specialties.length === 1 ? 1 : 0);\r\n\r\n        suggestions.push({\r\n          standardizedName,\r\n          confidence,\r\n          specialties\r\n        });\r\n      }\r\n    });\r\n\r\n    return suggestions.sort((a, b) => b.confidence - a.confidence);\r\n  }\r\n\r\n  private async saveLearningData(originalName: string, correctedName: string): Promise<void> {\r\n    try {\r\n      const learnedMappings = await this.storageService.getItem(this.LEARNED_MAPPINGS_KEY) || {};\r\n      learnedMappings[originalName.toLowerCase()] = correctedName;\r\n      await this.storageService.setItem(this.LEARNED_MAPPINGS_KEY, learnedMappings);\r\n    } catch (error) {\r\n      console.error('Error saving learning data:', error);\r\n    }\r\n  }\r\n\r\n  private async getLearnedMapping(specialty: string): Promise<string | null> {\r\n    try {\r\n      const learnedMappings = await this.storageService.getItem(this.LEARNED_MAPPINGS_KEY) || {};\r\n      return learnedMappings[specialty.toLowerCase()] || null;\r\n    } catch (error) {\r\n      console.error('Error getting learned mapping:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getLearnedMappings(): Promise<Record<string, string>> {\r\n    try {\r\n      return await this.storageService.getItem(this.LEARNED_MAPPINGS_KEY) || {};\r\n    } catch (error) {\r\n      console.error('Error getting learned mappings:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async removeLearnedMapping(originalName: string): Promise<void> {\r\n    try {\r\n      const learnedMappings = await this.getLearnedMappings();\r\n      delete learnedMappings[originalName.toLowerCase()];\r\n      await this.storageService.setItem(this.LEARNED_MAPPINGS_KEY, learnedMappings);\r\n    } catch (error) {\r\n      console.error('Error removing learned mapping:', error);\r\n    }\r\n  }\r\n} ","import { \r\n  ISurveyData, \r\n  ISurveyRow \r\n} from '../types/survey';\r\n\r\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\r\n\r\nclass BackendService {\r\n  private static instance: BackendService;\r\n\r\n  private constructor() {}\r\n\r\n  public static getInstance(): BackendService {\r\n    if (!BackendService.instance) {\r\n      BackendService.instance = new BackendService();\r\n    }\r\n    return BackendService.instance;\r\n  }\r\n\r\n  // Get survey metadata (includes original columns list)\r\n  public async getSurveyMeta(surveyId: string): Promise<{ columns?: string[] }> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/meta`);\r\n    if (!response.ok) throw new Error('Failed to fetch survey metadata');\r\n    return await response.json();\r\n  }\r\n\r\n  // Upload a survey file\r\n  public async uploadSurvey(\r\n    file: File,\r\n    surveyName: string,\r\n    surveyYear: number,\r\n    surveyType: string,\r\n    onProgress?: (percent: number) => void\r\n  ): Promise<{ surveyId: string; rowCount: number }> {\r\n    const formData = new FormData();\r\n    formData.append('file', file);\r\n    formData.append('name', surveyName);\r\n    formData.append('year', surveyYear.toString());\r\n    formData.append('type', surveyType);\r\n\r\n    // Use XHR to report real upload progress\r\n    const xhr = new XMLHttpRequest();\r\n    const promise = new Promise<{ surveyId: string; rowCount: number }>((resolve, reject) => {\r\n      xhr.open('POST', `${API_BASE_URL}/upload`);\r\n      xhr.onload = () => {\r\n        if (xhr.status >= 200 && xhr.status < 300) {\r\n          try {\r\n            const result = JSON.parse(xhr.responseText);\r\n            resolve({ surveyId: result.surveyId, rowCount: result.rowCount });\r\n          } catch (err) {\r\n            reject(new Error('Invalid server response'));\r\n          }\r\n        } else {\r\n          reject(new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`));\r\n        }\r\n      };\r\n      xhr.onerror = () => reject(new Error('Network error during upload'));\r\n      xhr.upload.onprogress = (event) => {\r\n        if (!onProgress || !event.lengthComputable) return;\r\n        const percent = Math.round((event.loaded / event.total) * 100);\r\n        onProgress(percent);\r\n      };\r\n      xhr.send(formData);\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  // Get all surveys\r\n  public async getAllSurveys(): Promise<ISurveyData[]> {\r\n    const response = await fetch(`${API_BASE_URL}/surveys`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to fetch surveys');\r\n    }\r\n\r\n    const surveys = await response.json();\r\n    \r\n    // Transform backend format to frontend format\r\n    return surveys.map((survey: any) => ({\r\n      id: survey.id,\r\n      name: survey.name,\r\n      year: survey.year.toString(),\r\n      type: survey.type,\r\n      uploadDate: survey.uploadDate,\r\n      rowCount: survey.rowCount ?? survey.row_count ?? 0,\r\n      specialtyCount: survey.specialtyCount ?? survey.specialty_count ?? 0,\r\n      dataPoints: survey.dataPoints ?? survey.data_points ?? 0,\r\n      colorAccent: survey.colorAccent || '#6366F1',\r\n      metadata: survey.metadata\r\n    }));\r\n  }\r\n\r\n  // Get survey data with filters\r\n  // CRITICAL: Always pass options.limit for large datasets to avoid missing data\r\n  // See docs/ALLERGY_IMMUNOLOGY_FIX.md for details on the 100-row default limit issue\r\n  public async getSurveyData(\r\n    surveyId: string,\r\n    filters?: {\r\n      specialty?: string;\r\n      providerType?: string;\r\n      region?: string;\r\n    },\r\n    options?: { page?: number; limit?: number }\r\n  ): Promise<{ rows: ISurveyRow[]; pagination?: { page: number; limit: number; total: number; pages: number } }>{\r\n    const params = new URLSearchParams();\r\n    if (filters?.specialty) params.append('specialty', filters.specialty);\r\n    if (filters?.providerType) params.append('providerType', filters.providerType);\r\n    if (filters?.region) params.append('region', filters.region);\r\n    if (options?.page) params.append('page', String(options.page));\r\n    if (options?.limit) params.append('limit', String(options.limit));\r\n\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/data?${params.toString()}`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to fetch survey data');\r\n    }\r\n\r\n    const data = await response.json();\r\n    \r\n    // Transform backend format to frontend format\r\n    // Backend returns { data: [...], pagination: {...} }\r\n    const surveyData = data.data || data;\r\n    // Keep all keys so the grid can render every original column.\r\n    const rows = surveyData.map((row: any) => ({ ...row }));\r\n    const pagination = data.pagination\r\n      ? {\r\n          page: Number(data.pagination.page) || 1,\r\n          limit: Number(data.pagination.limit) || rows.length,\r\n          total: Number(data.pagination.total) || rows.length,\r\n          pages: Number(data.pagination.pages) || 1,\r\n        }\r\n      : undefined;\r\n    return { rows, pagination };\r\n  }\r\n\r\n  // Get available filters\r\n  public async getAvailableFiltersForSurvey(surveyId: string): Promise<{\r\n    specialties: string[];\r\n    providerTypes: string[];\r\n    regions: string[];\r\n  }> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/filters`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to fetch filters');\r\n    }\r\n\r\n    return await response.json();\r\n  }\r\n\r\n  // Delete a survey\r\n  public async deleteSurvey(surveyId: string): Promise<void> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}`, {\r\n      method: 'DELETE',\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to delete survey');\r\n    }\r\n  }\r\n\r\n  // Delete all surveys\r\n  public async deleteAllSurveys(): Promise<void> {\r\n    const response = await fetch(`${API_BASE_URL}/surveys`, { method: 'DELETE' });\r\n    if (!response.ok) throw new Error('Failed to delete all surveys');\r\n  }\r\n\r\n  // Export survey data\r\n  public async exportSurveyData(\r\n    surveyId: string,\r\n    format: 'csv' | 'json' = 'csv'\r\n  ): Promise<Blob> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/export?format=${format}`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to export survey data');\r\n    }\r\n\r\n    return await response.blob();\r\n  }\r\n\r\n  // Health check\r\n  public async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const response = await fetch(`${API_BASE_URL}/health`);\r\n      return response.ok;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\nexport default BackendService;\r\n"],"names":["SpecialtyMappingService","constructor","storageService","MAPPINGS_KEY","GROUPS_KEY","LEARNED_MAPPINGS_KEY","specialtyCache","Map","cacheExpiry","CACHE_TTL","SYNONYMS","this","saveMapping","mapping","payload","standardizedName","sourceSpecialties","map","s","specialty","originalName","surveySource","fetch","concat","process","REACT_APP_API_URL","method","headers","body","JSON","stringify","getAllMappings","res","ok","Error","json","error","console","getUnmappedSpecialties","log","backendService","BackendService","getInstance","surveys","getAllSurveys","length","mappings","unmappedSpecialties","mappedNames","Set","forEach","add","toLowerCase","source","Array","from","batchSize","i","batch","slice","Math","floor","ceil","batchPromises","async","survey","id","rows","getSurveyData","page","limit","counts","row","index","Object","keys","possibleSpecialtyColumns","colName","trim","key","set","get","entries","type","surveyProvider","Promise","all","_ref","count","has","push","name","frequency","autoMapSpecialties","config","unmapped","existingMappings","newMappings","failedMappings","batches","batchIndex","processSpecialtyWithRetry","allSettled","result","_result$reason","status","value","reason","message","warn","maxRetries","attempt","bestMatch","findBestMatch","confidence","confidenceThreshold","find","m","crypto","randomUUID","mappingId","resolve","setTimeout","pow","findSuggestedMatches","calculateConfidence","filter","match","sort","a","b","useFuzzyMatching","arguments","undefined","useSynonyms","maxConfidence","specialtyLower","standardizedLower","getLearnedMapping","then","learnedMapping","includes","synonyms","isSpecialtyMatch","some","syn","isStandardizedMatch","max","similarity","stringSimilarity","sourceLower","sourceSimilarity","saveGroup","group","groups","getAllGroups","existingIndex","findIndex","g","_objectSpread","updatedAt","Date","now","createdAt","storeSurveyData","metadata","totalRows","uniqueSpecialties","uniqueProviderTypes","uniqueRegions","columnMappings","_unused","deleteGroup","groupId","filteredGroups","getMappings","getItem","createMapping","saveLearningData","updateMapping","updates","updatedMapping","deleteMapping","clearAllMappings","setItem","suggestMappings","suggestions","maxSimilarity","standardizedSimilarity","calculateSimilarity","suggestion","str1","str2","createGroup","selectedSpecialties","replace","generateMappingSuggestions","useExistingMappings","normalizeString","str","normalized","normalized1","normalized2","foundMatch","matched","_ref2","_ref3","specialties","totalConfidence","comparisons","j","correctedName","learnedMappings","getLearnedMappings","removeLearnedMapping","API_BASE_URL","instance","getSurveyMeta","surveyId","response","uploadSurvey","file","surveyName","surveyYear","surveyType","onProgress","formData","FormData","append","toString","xhr","XMLHttpRequest","reject","open","onload","parse","responseText","rowCount","err","statusText","onerror","upload","onprogress","event","lengthComputable","percent","round","loaded","total","send","_survey$rowCount","_survey$specialtyCoun","_survey$dataPoints","year","uploadDate","row_count","specialtyCount","specialty_count","dataPoints","data_points","colorAccent","filters","options","params","URLSearchParams","providerType","region","String","data","pagination","Number","pages","getAvailableFiltersForSurvey","deleteSurvey","deleteAllSurveys","exportSurveyData","format","blob","healthCheck"],"sourceRoot":""}