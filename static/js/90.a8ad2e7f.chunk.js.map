{"version":3,"file":"static/js/90.a8ad2e7f.chunk.js","mappings":"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","sources":["services/SpecialtyMappingService.ts","services/BackendService.ts"],"sourcesContent":["import { ISpecialtyMapping, ISourceSpecialty, IUnmappedSpecialty, IAutoMappingConfig, ISurveyData, ISpecialtyGroup, IMappingSuggestion } from '../types/specialty';\r\nimport { stringSimilarity } from 'string-similarity-js';\r\nimport { LocalStorageService } from './StorageService';\r\nimport BackendService from './BackendService';\r\nimport { ISurveyRow } from '../types/survey';\r\n\r\nexport class SpecialtyMappingService {\r\n  private readonly MAPPINGS_KEY = 'specialty-mappings';\r\n  private readonly storageService: LocalStorageService;\r\n  private readonly GROUPS_KEY = 'specialty_groups';\r\n  private readonly LEARNED_MAPPINGS_KEY = 'learned-specialty-mappings';\r\n  \r\n  // Add caching for performance\r\n  private specialtyCache = new Map<string, Set<string>>();\r\n  private cacheExpiry = new Map<string, number>();\r\n  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes\r\n\r\n  private readonly SYNONYMS: Record<string, string[]> = {\r\n    'cardiology': ['heart', 'cardiac', 'cardiovascular'],\r\n    'orthopedics': ['ortho', 'orthopedic', 'orthopaedic'],\r\n    'pediatrics': ['peds', 'pediatric', 'children'],\r\n    'critical care': [\r\n      'intensivist', \r\n      'critical care medicine', \r\n      'critical care/intensivist', \r\n      'intensive care',\r\n      'critical care medicine',\r\n      'cc medicine',\r\n      'cc/intensivist',\r\n      'icu'\r\n    ],\r\n    'emergency medicine': ['emergency', 'er', 'ed'],\r\n    'internal medicine': ['internist', 'internal med'],\r\n    'obstetrics': ['ob/gyn', 'obgyn', 'obstetrics and gynecology', 'obstetrics & gynecology'],\r\n    'anesthesiology': ['anesthesia', 'anesthetist'],\r\n    'family medicine': ['family practice', 'family physician', 'family med'],\r\n    'neurology': ['neurological', 'neuro'],\r\n    'psychiatry': ['psychiatric', 'mental health'],\r\n    'radiology': ['radiologist', 'imaging', 'diagnostic radiology'],\r\n    'surgery': ['surgeon', 'surgical']\r\n  };\r\n\r\n  constructor(storageService: LocalStorageService) {\r\n    this.storageService = storageService;\r\n  }\r\n\r\n  async saveMapping(mapping: ISpecialtyMapping): Promise<void> {\r\n    // Persist to backend API\r\n    const payload = {\r\n      standardizedName: mapping.standardizedName,\r\n      sourceSpecialties: mapping.sourceSpecialties.map(s => ({\r\n        specialty: s.specialty,\r\n        originalName: s.originalName,\r\n        surveySource: s.surveySource\r\n      }))\r\n    };\r\n    await fetch('http://localhost:3001/api/mappings/specialty', {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify(payload)\r\n    });\r\n  }\r\n\r\n  async getAllMappings(): Promise<ISpecialtyMapping[]> {\r\n    try {\r\n      const res = await fetch('http://localhost:3001/api/mappings/specialty');\r\n      if (!res.ok) throw new Error('Failed to fetch');\r\n      const data = await res.json();\r\n      return data as ISpecialtyMapping[];\r\n    } catch (error) {\r\n      console.error('Error fetching specialty mappings:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async getUnmappedSpecialties(): Promise<IUnmappedSpecialty[]> {\r\n    try {\r\n      console.log('🔄 Fetching unmapped specialties with caching...');\r\n      \r\n      // Get all surveys from backend\r\n      const backendService = BackendService.getInstance();\r\n      console.log('📡 Calling backendService.getAllSurveys()...');\r\n      const surveys = await backendService.getAllSurveys();\r\n      console.log('📊 Surveys received:', surveys.length, surveys);\r\n      \r\n      const mappings = await this.getAllMappings();\r\n      console.log('🗺️ Existing mappings:', mappings.length);\r\n      \r\n      const unmappedSpecialties: IUnmappedSpecialty[] = [];\r\n      const mappedNames = new Set<string>();\r\n\r\n      // Collect all mapped specialty names (both standardized and original names)\r\n      mappings.forEach(mapping => {\r\n        mappedNames.add(mapping.standardizedName.toLowerCase());\r\n        mapping.sourceSpecialties.forEach((source: ISourceSpecialty) => {\r\n          mappedNames.add(source.specialty.toLowerCase());\r\n        });\r\n      });\r\n      console.log('✅ Mapped names collected:', Array.from(mappedNames));\r\n\r\n      // Process surveys in batches for better performance\r\n      const batchSize = 10;\r\n\r\n      for (let i = 0; i < surveys.length; i += batchSize) {\r\n        const batch = surveys.slice(i, i + batchSize);\r\n        console.log(`📦 Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(surveys.length / batchSize)}`);\r\n        \r\n        const batchPromises = batch.map(async (survey) => {\r\n          try {\r\n            // Fetch from backend\r\n            console.log(`🔍 Fetching data for survey ${survey.id}...`);\r\n            const { rows } = await backendService.getSurveyData(survey.id, {}, { page: 1, limit: 10000 });\r\n            console.log(`📋 Survey ${survey.id} returned ${rows.length} rows`);\r\n            \r\n            // Extract specialties and count per survey\r\n            const counts = new Map<string, number>();\r\n            \r\n            rows.forEach((row: any, index: number) => {\r\n              // Log all column names from first row\r\n              if (index === 0) {\r\n                console.log('📋 All column names in row:', Object.keys(row));\r\n              }\r\n              \r\n              // Check multiple possible specialty column names\r\n              const possibleSpecialtyColumns = [\r\n                'specialty', 'Specialty', 'Provider Type', 'provider_type', \r\n                'ProviderType', 'specialty_name', 'SpecialtyName', 'specialtyName',\r\n                'PROVIDER_TYPE', 'SPECIALTY', 'Specialty Type', 'specialty_type'\r\n              ];\r\n              \r\n              let specialty = '';\r\n              for (const colName of possibleSpecialtyColumns) {\r\n                if (row[colName] && typeof row[colName] === 'string' && row[colName].trim()) {\r\n                  specialty = row[colName].trim();\r\n                  console.log(`✅ Found specialty in column \"${colName}\": ${specialty}`);\r\n                  break;\r\n                }\r\n              }\r\n              \r\n              if (specialty) {\r\n                const key = specialty;\r\n                counts.set(key, (counts.get(key) || 0) + 1);\r\n              }\r\n              \r\n              // Log first few rows for debugging\r\n              if (index < 5) {\r\n                console.log(`Row ${index}:`, { specialty, row });\r\n              }\r\n            });\r\n\r\n            console.log(`🏥 Found specialties in survey ${survey.id}:`, Array.from(counts.entries()));\r\n\r\n            const surveySource = (survey as any).type || (survey as any).surveyProvider || 'Unknown';\r\n            return { surveySource, counts };\r\n          } catch (error) {\r\n            console.error(`❌ Error processing survey ${survey.id}:`, error);\r\n            return { surveySource: 'Unknown', counts: new Map<string, number>() };\r\n          }\r\n        });\r\n\r\n        const batchResults = await Promise.all(batchPromises);\r\n        \r\n        // Convert per-survey counts into unmapped entries (one per survey source)\r\n        batchResults.forEach(({ surveySource, counts }) => {\r\n                      counts.forEach((count, specialty) => {\r\n              const key = specialty.toLowerCase();\r\n              if (!mappedNames.has(key)) {\r\n                unmappedSpecialties.push({\r\n                  id: `${surveySource}-${specialty}`,\r\n                  name: specialty,\r\n                  surveySource,\r\n                  frequency: count\r\n                });\r\n              }\r\n            });\r\n        });\r\n      }\r\n\r\n      console.log(`✅ Found ${unmappedSpecialties.length} unmapped specialties:`, unmappedSpecialties);\r\n      return unmappedSpecialties;\r\n    } catch (error) {\r\n      console.error('❌ Error getting unmapped specialties:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async autoMapSpecialties(config: IAutoMappingConfig): Promise<ISpecialtyMapping[]> {\r\n    console.log('🚀 Starting auto-mapping with retry logic...');\r\n    \r\n    const unmapped = await this.getUnmappedSpecialties();\r\n    const existingMappings = await this.getAllMappings();\r\n    const newMappings: ISpecialtyMapping[] = [];\r\n    const failedMappings: Array<{ specialty: string; error: string }> = [];\r\n\r\n    // Process in batches with retry logic\r\n    const batchSize = 50;\r\n    const batches = [];\r\n    \r\n    for (let i = 0; i < unmapped.length; i += batchSize) {\r\n      batches.push(unmapped.slice(i, i + batchSize));\r\n    }\r\n\r\n    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {\r\n      const batch = batches[batchIndex];\r\n      console.log(`📦 Processing auto-mapping batch ${batchIndex + 1}/${batches.length}`);\r\n      \r\n      const batchPromises = batch.map(async (specialty) => {\r\n        return this.processSpecialtyWithRetry(specialty, existingMappings, config, 3);\r\n      });\r\n\r\n      const batchResults = await Promise.allSettled(batchPromises);\r\n      \r\n      batchResults.forEach((result, index) => {\r\n        const specialty = batch[index];\r\n        if (result.status === 'fulfilled' && result.value) {\r\n          newMappings.push(result.value);\r\n        } else {\r\n          failedMappings.push({\r\n            specialty: specialty.name,\r\n            error: result.status === 'rejected' ? result.reason?.message || 'Unknown error' : 'Failed to process'\r\n          });\r\n        }\r\n      });\r\n    }\r\n\r\n    console.log(`✅ Auto-mapping completed: ${newMappings.length} successful, ${failedMappings.length} failed`);\r\n    \r\n    if (failedMappings.length > 0) {\r\n      console.warn('⚠️ Failed mappings:', failedMappings);\r\n    }\r\n\r\n    return newMappings;\r\n  }\r\n\r\n  private async processSpecialtyWithRetry(\r\n    specialty: IUnmappedSpecialty,\r\n    existingMappings: ISpecialtyMapping[],\r\n    config: IAutoMappingConfig,\r\n    maxRetries: number\r\n  ): Promise<ISpecialtyMapping | null> {\r\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\r\n      try {\r\n        const bestMatch = this.findBestMatch(specialty.name, existingMappings, config);\r\n\r\n        if (bestMatch && bestMatch.confidence >= config.confidenceThreshold) {\r\n          const mapping = existingMappings.find(m => m.standardizedName === bestMatch.standardizedName);\r\n          if (mapping) {\r\n            mapping.sourceSpecialties.push({\r\n              id: crypto.randomUUID(),\r\n              specialty: specialty.name,\r\n              originalName: specialty.name,\r\n              surveySource: specialty.surveySource,\r\n              mappingId: mapping.id\r\n            });\r\n            await this.saveMapping(mapping);\r\n            return mapping;\r\n          }\r\n        }\r\n        return null; // No match found, not an error\r\n      } catch (error) {\r\n        console.error(`Attempt ${attempt} failed for specialty ${specialty.name}:`, error);\r\n        if (attempt === maxRetries) {\r\n          throw error;\r\n        }\r\n        // Wait before retry (exponential backoff)\r\n        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private findSuggestedMatches(\r\n    specialty: string,\r\n    existingMappings: ISpecialtyMapping[]\r\n  ): Array<{ standardizedName: string; confidence: number }> {\r\n    return existingMappings\r\n      .map(mapping => ({\r\n        standardizedName: mapping.standardizedName,\r\n        confidence: this.calculateConfidence(specialty, mapping)\r\n      }))\r\n      .filter(match => match.confidence > 0.3)\r\n      .sort((a, b) => b.confidence - a.confidence)\r\n      .slice(0, 5);\r\n  }\r\n\r\n  private findBestMatch(\r\n    specialty: string,\r\n    existingMappings: ISpecialtyMapping[],\r\n    config: IAutoMappingConfig\r\n  ): { standardizedName: string; confidence: number } | null {\r\n    const matches = existingMappings\r\n      .map(mapping => ({\r\n        standardizedName: mapping.standardizedName,\r\n        confidence: this.calculateConfidence(\r\n          specialty,\r\n          mapping,\r\n          config.useFuzzyMatching,\r\n          true\r\n        )\r\n      }))\r\n      .filter(match => match.confidence >= config.confidenceThreshold)\r\n      .sort((a, b) => b.confidence - a.confidence);\r\n\r\n    return matches[0] || null;\r\n  }\r\n\r\n  private calculateConfidence(\r\n    specialty: string,\r\n    mapping: ISpecialtyMapping,\r\n    useFuzzyMatching: boolean = true,\r\n    useSynonyms: boolean = true\r\n  ): number {\r\n    let maxConfidence = 0;\r\n    const specialtyLower = specialty.toLowerCase();\r\n    const standardizedLower = mapping.standardizedName.toLowerCase();\r\n\r\n    // Check learned mappings first\r\n    this.getLearnedMapping(specialty).then(learnedMapping => {\r\n      if (learnedMapping && learnedMapping === mapping.standardizedName) {\r\n        return 1.0;\r\n      }\r\n    });\r\n\r\n    // Direct match check\r\n    if (specialtyLower === standardizedLower) {\r\n      return 1.0;\r\n    }\r\n\r\n    // Critical Care specific matching\r\n    if (specialtyLower.includes('critical care') || \r\n        specialtyLower.includes('intensivist') || \r\n        standardizedLower.includes('critical care') || \r\n        standardizedLower.includes('intensivist')) {\r\n      // If both terms are related to critical care, give very high confidence\r\n      if ((specialtyLower.includes('critical care') || specialtyLower.includes('intensivist')) &&\r\n          (standardizedLower.includes('critical care') || standardizedLower.includes('intensivist'))) {\r\n        return 0.95; // Very high confidence for critical care variations\r\n      }\r\n    }\r\n\r\n    // Synonym check\r\n    if (useSynonyms) {\r\n      for (const [key, synonyms] of Object.entries(this.SYNONYMS)) {\r\n        const isSpecialtyMatch = specialtyLower.includes(key) || \r\n          synonyms.some(syn => specialtyLower.includes(syn));\r\n        const isStandardizedMatch = standardizedLower.includes(key) || \r\n          synonyms.some(syn => standardizedLower.includes(syn));\r\n        \r\n        if (isSpecialtyMatch && isStandardizedMatch) {\r\n          maxConfidence = Math.max(maxConfidence, 0.9);\r\n        }\r\n      }\r\n    }\r\n\r\n    // String similarity check\r\n    if (useFuzzyMatching) {\r\n      const similarity = stringSimilarity(specialtyLower, standardizedLower);\r\n      maxConfidence = Math.max(maxConfidence, similarity);\r\n\r\n      // Check against all source names\r\n      for (const source of mapping.sourceSpecialties) {\r\n        const sourceLower = source.specialty.toLowerCase();\r\n        \r\n        // Direct match with source\r\n        if (specialtyLower === sourceLower) {\r\n          return 1.0;\r\n        }\r\n        \r\n        const sourceSimilarity = stringSimilarity(specialtyLower, sourceLower);\r\n        maxConfidence = Math.max(maxConfidence, sourceSimilarity);\r\n\r\n        // Additional check for partial matches\r\n        if (specialtyLower.includes(sourceLower) || sourceLower.includes(specialtyLower)) {\r\n          maxConfidence = Math.max(maxConfidence, 0.85);\r\n        }\r\n      }\r\n    }\r\n\r\n    return maxConfidence;\r\n  }\r\n\r\n  // Group management methods\r\n  async saveGroup(group: ISpecialtyGroup): Promise<void> {\r\n    const groups = await this.getAllGroups();\r\n    const existingIndex = groups.findIndex(g => g.id === group.id);\r\n    \r\n    if (existingIndex >= 0) {\r\n      groups[existingIndex] = {\r\n        ...group,\r\n        updatedAt: new Date()\r\n      };\r\n    } else {\r\n      const now = new Date();\r\n      groups.push({\r\n        ...group,\r\n        createdAt: now,\r\n        updatedAt: now\r\n      });\r\n    }\r\n\r\n    await this.storageService.storeSurveyData<ISpecialtyGroup>({\r\n      id: this.GROUPS_KEY,\r\n      metadata: { \r\n        type: 'specialty_groups',\r\n        totalRows: groups.length,\r\n        uniqueSpecialties: [],\r\n        uniqueProviderTypes: [],\r\n        uniqueRegions: [],\r\n        columnMappings: {}\r\n      },\r\n      rows: groups\r\n    });\r\n  }\r\n\r\n  async getAllGroups(): Promise<ISpecialtyGroup[]> {\r\n    try {\r\n      const result = await this.storageService.getSurveyData<ISpecialtyGroup>(this.GROUPS_KEY);\r\n      return result.rows;\r\n    } catch {\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async deleteGroup(groupId: string): Promise<void> {\r\n    const groups = await this.getAllGroups();\r\n    const filteredGroups = groups.filter(g => g.id !== groupId);\r\n    \r\n    await this.storageService.storeSurveyData<ISpecialtyGroup>({\r\n      id: this.GROUPS_KEY,\r\n      metadata: { \r\n        type: 'specialty_groups',\r\n        totalRows: filteredGroups.length,\r\n        uniqueSpecialties: [],\r\n        uniqueProviderTypes: [],\r\n        uniqueRegions: [],\r\n        columnMappings: {}\r\n      },\r\n      rows: filteredGroups\r\n    });\r\n  }\r\n\r\n  async getMappings(): Promise<ISpecialtyMapping[]> {\r\n    try {\r\n      const mappings = await this.storageService.getItem(this.MAPPINGS_KEY) as ISpecialtyMapping[];\r\n      return mappings || [];\r\n    } catch (error) {\r\n      console.error('Error fetching specialty mappings:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  async createMapping(standardizedName: string, sourceSpecialties: ISourceSpecialty[]): Promise<ISpecialtyMapping> {\r\n    const mapping: ISpecialtyMapping = {\r\n      id: crypto.randomUUID(),\r\n      standardizedName,\r\n      sourceSpecialties: sourceSpecialties.map(s => ({\r\n        ...s,\r\n        mappingId: crypto.randomUUID()\r\n      })),\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n\r\n    // Learn from new mappings\r\n    for (const specialty of sourceSpecialties) {\r\n      if (specialty.specialty !== standardizedName) {\r\n        await this.saveLearningData(specialty.specialty, standardizedName);\r\n      }\r\n    }\r\n\r\n    await this.saveMapping(mapping);\r\n    return mapping;\r\n  }\r\n\r\n  async updateMapping(mappingId: string, updates: Partial<ISpecialtyMapping>): Promise<ISpecialtyMapping> {\r\n    const mappings = await this.getMappings();\r\n    const index = mappings.findIndex(m => m.id === mappingId);\r\n    \r\n    if (index === -1) {\r\n      throw new Error(`Mapping with id ${mappingId} not found`);\r\n    }\r\n\r\n    // Learn from this correction\r\n    if (updates.standardizedName && updates.standardizedName !== mappings[index].standardizedName) {\r\n      await this.saveLearningData(mappings[index].standardizedName, updates.standardizedName);\r\n    }\r\n\r\n    const updatedMapping = {\r\n      ...mappings[index],\r\n      ...updates,\r\n      updatedAt: new Date()\r\n    };\r\n\r\n    // Update via backend API\r\n    await fetch(`http://localhost:3001/api/mappings/specialty/${mappingId}`, {\r\n      method: 'PUT',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify(updatedMapping)\r\n    });\r\n\r\n    return updatedMapping;\r\n  }\r\n\r\n  async deleteMapping(mappingId: string): Promise<void> {\r\n    // Delete via backend API\r\n    await fetch(`http://localhost:3001/api/mappings/specialty/${mappingId}`, {\r\n      method: 'DELETE'\r\n    });\r\n  }\r\n\r\n  async clearAllMappings(): Promise<void> {\r\n    // Clear via backend API\r\n    await fetch('http://localhost:3001/api/mappings/specialty', {\r\n      method: 'DELETE'\r\n    });\r\n    await this.storageService.setItem(this.LEARNED_MAPPINGS_KEY, {});\r\n  }\r\n\r\n  async suggestMappings(specialty: IUnmappedSpecialty, config: IAutoMappingConfig): Promise<ISpecialtyMapping[]> {\r\n    const mappings = await this.getMappings();\r\n    const suggestions: Array<{ mapping: ISpecialtyMapping; similarity: number }> = [];\r\n\r\n    for (const mapping of mappings) {\r\n      let maxSimilarity = 0;\r\n\r\n      // Compare with standardized name\r\n      const standardizedSimilarity = this.calculateSimilarity(\r\n        specialty.name,\r\n        mapping.standardizedName,\r\n        config\r\n      );\r\n      maxSimilarity = Math.max(maxSimilarity, standardizedSimilarity);\r\n\r\n      // Compare with source specialties\r\n      for (const source of mapping.sourceSpecialties) {\r\n        const sourceSimilarity = this.calculateSimilarity(\r\n          specialty.name,\r\n          source.specialty,\r\n          config\r\n        );\r\n        maxSimilarity = Math.max(maxSimilarity, sourceSimilarity);\r\n      }\r\n\r\n      if (maxSimilarity >= config.confidenceThreshold) {\r\n        suggestions.push({ mapping, similarity: maxSimilarity });\r\n      }\r\n    }\r\n\r\n    return suggestions\r\n      .sort((a, b) => b.similarity - a.similarity)\r\n      .map(suggestion => suggestion.mapping);\r\n  }\r\n\r\n  private calculateSimilarity(str1: string, str2: string, config: IAutoMappingConfig): number {\r\n    // Always case-insensitive comparison\r\n    str1 = str1.toLowerCase();\r\n    str2 = str2.toLowerCase();\r\n\r\n    if (str1 === str2) return 1;\r\n    if (!config.useFuzzyMatching) return 0;\r\n\r\n    return stringSimilarity(str1, str2);\r\n  }\r\n\r\n  async createGroup(standardizedName: string, selectedSpecialties: IUnmappedSpecialty[]): Promise<ISpecialtyGroup> {\r\n    const now = new Date();\r\n    const group: ISpecialtyGroup = {\r\n      id: `${standardizedName}`.toLowerCase().replace(/\\s+/g, '-'),\r\n      standardizedName,\r\n      selectedSpecialties,\r\n      createdAt: now,\r\n      updatedAt: now\r\n    };\r\n    \r\n    await this.saveGroup(group);\r\n    return group;\r\n  }\r\n\r\n  async generateMappingSuggestions(config: IAutoMappingConfig): Promise<IMappingSuggestion[]> {\r\n    const unmappedSpecialties = await this.getUnmappedSpecialties();\r\n    const existingMappings = config.useExistingMappings ? await this.getAllMappings() : [];\r\n    const suggestions: IMappingSuggestion[] = [];\r\n\r\n    // Group specialties by similar names\r\n    const groups = new Map<string, Array<{ name: string; surveySource: string }>>();\r\n\r\n    // Helper function to normalize strings for comparison\r\n    const normalizeString = (str: string): string => {\r\n      let normalized = str.toLowerCase();\r\n      if (!config.useFuzzyMatching) {\r\n        // Only basic normalization if fuzzy matching is disabled\r\n        return normalized.trim();\r\n      }\r\n      // More aggressive normalization for fuzzy matching\r\n      normalized = normalized\r\n        .replace(/[^a-z0-9\\s]/g, '') // Remove special characters\r\n        .replace(/\\s+/g, ' ') // Normalize whitespace\r\n        .trim();\r\n      return normalized;\r\n    };\r\n\r\n    // Function to calculate similarity between two strings\r\n    const calculateSimilarity = (str1: string, str2: string): number => {\r\n      const normalized1 = normalizeString(str1);\r\n      const normalized2 = normalizeString(str2);\r\n      \r\n      if (!config.useFuzzyMatching) {\r\n        // Exact match when fuzzy matching is disabled\r\n        return normalized1 === normalized2 ? 1 : 0;\r\n      }\r\n      \r\n      return stringSimilarity(normalized1, normalized2);\r\n    };\r\n\r\n    // First pass: group by exact matches\r\n    unmappedSpecialties.forEach(specialty => {\r\n      let foundMatch = false;\r\n      \r\n      // Check against existing mappings first\r\n      if (config.useExistingMappings) {\r\n        for (const mapping of existingMappings) {\r\n          const similarity = calculateSimilarity(specialty.name, mapping.standardizedName);\r\n          if (similarity >= config.confidenceThreshold) {\r\n            const key = mapping.standardizedName;\r\n            const group = groups.get(key) || [];\r\n            group.push({ name: specialty.name, surveySource: specialty.surveySource as any });\r\n            groups.set(key, group);\r\n            foundMatch = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!foundMatch) {\r\n        // Try to match with other unmapped specialties\r\n        let matched = false;\r\n        // Convert Map.entries() to Array to avoid iterator issues\r\n        Array.from(groups.entries()).forEach(([key, group]) => {\r\n          if (!matched) {\r\n            const similarity = calculateSimilarity(specialty.name, key);\r\n            if (similarity >= config.confidenceThreshold) {\r\n              group.push({ name: specialty.name, surveySource: specialty.surveySource as any });\r\n              matched = true;\r\n            }\r\n          }\r\n        });\r\n\r\n        if (!matched) {\r\n          // Create new group\r\n          groups.set(specialty.name, [{ name: specialty.name, surveySource: specialty.surveySource as any }]);\r\n        }\r\n      }\r\n    });\r\n\r\n    // Convert groups to suggestions\r\n    // Convert Map.entries() to Array to avoid iterator issues\r\n    Array.from(groups.entries()).forEach(([standardizedName, specialties]) => {\r\n      if (specialties.length > 0) {\r\n        // Calculate average confidence for the group\r\n        let totalConfidence = 0;\r\n        let comparisons = 0;\r\n\r\n        for (let i = 0; i < specialties.length; i++) {\r\n          for (let j = i + 1; j < specialties.length; j++) {\r\n            totalConfidence += calculateSimilarity(specialties[i].name, specialties[j].name);\r\n            comparisons++;\r\n          }\r\n        }\r\n\r\n        const confidence = comparisons > 0 \r\n          ? totalConfidence / comparisons \r\n          : (specialties.length === 1 ? 1 : 0);\r\n\r\n        suggestions.push({\r\n          standardizedName,\r\n          confidence,\r\n          specialties\r\n        });\r\n      }\r\n    });\r\n\r\n    return suggestions.sort((a, b) => b.confidence - a.confidence);\r\n  }\r\n\r\n  private async saveLearningData(originalName: string, correctedName: string): Promise<void> {\r\n    try {\r\n      const learnedMappings = await this.storageService.getItem(this.LEARNED_MAPPINGS_KEY) || {};\r\n      learnedMappings[originalName.toLowerCase()] = correctedName;\r\n      await this.storageService.setItem(this.LEARNED_MAPPINGS_KEY, learnedMappings);\r\n    } catch (error) {\r\n      console.error('Error saving learning data:', error);\r\n    }\r\n  }\r\n\r\n  private async getLearnedMapping(specialty: string): Promise<string | null> {\r\n    try {\r\n      const learnedMappings = await this.storageService.getItem(this.LEARNED_MAPPINGS_KEY) || {};\r\n      return learnedMappings[specialty.toLowerCase()] || null;\r\n    } catch (error) {\r\n      console.error('Error getting learned mapping:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  async getLearnedMappings(): Promise<Record<string, string>> {\r\n    try {\r\n      return await this.storageService.getItem(this.LEARNED_MAPPINGS_KEY) || {};\r\n    } catch (error) {\r\n      console.error('Error getting learned mappings:', error);\r\n      return {};\r\n    }\r\n  }\r\n\r\n  async removeLearnedMapping(originalName: string): Promise<void> {\r\n    try {\r\n      const learnedMappings = await this.getLearnedMappings();\r\n      delete learnedMappings[originalName.toLowerCase()];\r\n      await this.storageService.setItem(this.LEARNED_MAPPINGS_KEY, learnedMappings);\r\n    } catch (error) {\r\n      console.error('Error removing learned mapping:', error);\r\n    }\r\n  }\r\n} ","import { \r\n  ISurveyData, \r\n  ISurveyRow \r\n} from '../types/survey';\r\n\r\nconst API_BASE_URL = 'http://localhost:3001/api';\r\n\r\nclass BackendService {\r\n  private static instance: BackendService;\r\n\r\n  private constructor() {}\r\n\r\n  public static getInstance(): BackendService {\r\n    if (!BackendService.instance) {\r\n      BackendService.instance = new BackendService();\r\n    }\r\n    return BackendService.instance;\r\n  }\r\n\r\n  // Get survey metadata (includes original columns list)\r\n  public async getSurveyMeta(surveyId: string): Promise<{ columns?: string[] }> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/meta`);\r\n    if (!response.ok) throw new Error('Failed to fetch survey metadata');\r\n    return await response.json();\r\n  }\r\n\r\n  // Upload a survey file\r\n  public async uploadSurvey(\r\n    file: File,\r\n    surveyName: string,\r\n    surveyYear: number,\r\n    surveyType: string,\r\n    onProgress?: (percent: number) => void\r\n  ): Promise<{ surveyId: string; rowCount: number }> {\r\n    const formData = new FormData();\r\n    formData.append('file', file);\r\n    formData.append('name', surveyName);\r\n    formData.append('year', surveyYear.toString());\r\n    formData.append('type', surveyType);\r\n\r\n    // Use XHR to report real upload progress\r\n    const xhr = new XMLHttpRequest();\r\n    const promise = new Promise<{ surveyId: string; rowCount: number }>((resolve, reject) => {\r\n      xhr.open('POST', `${API_BASE_URL}/upload`);\r\n      xhr.onload = () => {\r\n        if (xhr.status >= 200 && xhr.status < 300) {\r\n          try {\r\n            const result = JSON.parse(xhr.responseText);\r\n            resolve({ surveyId: result.surveyId, rowCount: result.rowCount });\r\n          } catch (err) {\r\n            reject(new Error('Invalid server response'));\r\n          }\r\n        } else {\r\n          reject(new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`));\r\n        }\r\n      };\r\n      xhr.onerror = () => reject(new Error('Network error during upload'));\r\n      xhr.upload.onprogress = (event) => {\r\n        if (!onProgress || !event.lengthComputable) return;\r\n        const percent = Math.round((event.loaded / event.total) * 100);\r\n        onProgress(percent);\r\n      };\r\n      xhr.send(formData);\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  // Get all surveys\r\n  public async getAllSurveys(): Promise<ISurveyData[]> {\r\n    const response = await fetch(`${API_BASE_URL}/surveys`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to fetch surveys');\r\n    }\r\n\r\n    const surveys = await response.json();\r\n    \r\n    // Transform backend format to frontend format\r\n    return surveys.map((survey: any) => ({\r\n      id: survey.id,\r\n      name: survey.name,\r\n      year: survey.year.toString(),\r\n      type: survey.type,\r\n      uploadDate: survey.uploadDate,\r\n      rowCount: survey.rowCount ?? survey.row_count ?? 0,\r\n      specialtyCount: survey.specialtyCount ?? survey.specialty_count ?? 0,\r\n      dataPoints: survey.dataPoints ?? survey.data_points ?? 0,\r\n      colorAccent: survey.colorAccent || '#6366F1',\r\n      metadata: survey.metadata\r\n    }));\r\n  }\r\n\r\n  // Get survey data with filters\r\n  // CRITICAL: Always pass options.limit for large datasets to avoid missing data\r\n  // See docs/ALLERGY_IMMUNOLOGY_FIX.md for details on the 100-row default limit issue\r\n  public async getSurveyData(\r\n    surveyId: string,\r\n    filters?: {\r\n      specialty?: string;\r\n      providerType?: string;\r\n      region?: string;\r\n    },\r\n    options?: { page?: number; limit?: number }\r\n  ): Promise<{ rows: ISurveyRow[]; pagination?: { page: number; limit: number; total: number; pages: number } }>{\r\n    const params = new URLSearchParams();\r\n    if (filters?.specialty) params.append('specialty', filters.specialty);\r\n    if (filters?.providerType) params.append('providerType', filters.providerType);\r\n    if (filters?.region) params.append('region', filters.region);\r\n    if (options?.page) params.append('page', String(options.page));\r\n    if (options?.limit) params.append('limit', String(options.limit));\r\n\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/data?${params.toString()}`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to fetch survey data');\r\n    }\r\n\r\n    const data = await response.json();\r\n    \r\n    // Transform backend format to frontend format\r\n    // Backend returns { data: [...], pagination: {...} }\r\n    const surveyData = data.data || data;\r\n    // Keep all keys so the grid can render every original column.\r\n    const rows = surveyData.map((row: any) => ({ ...row }));\r\n    const pagination = data.pagination\r\n      ? {\r\n          page: Number(data.pagination.page) || 1,\r\n          limit: Number(data.pagination.limit) || rows.length,\r\n          total: Number(data.pagination.total) || rows.length,\r\n          pages: Number(data.pagination.pages) || 1,\r\n        }\r\n      : undefined;\r\n    return { rows, pagination };\r\n  }\r\n\r\n  // Get available filters\r\n  public async getAvailableFiltersForSurvey(surveyId: string): Promise<{\r\n    specialties: string[];\r\n    providerTypes: string[];\r\n    regions: string[];\r\n  }> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/filters`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to fetch filters');\r\n    }\r\n\r\n    return await response.json();\r\n  }\r\n\r\n  // Delete a survey\r\n  public async deleteSurvey(surveyId: string): Promise<void> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}`, {\r\n      method: 'DELETE',\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to delete survey');\r\n    }\r\n  }\r\n\r\n  // Delete all surveys\r\n  public async deleteAllSurveys(): Promise<void> {\r\n    const response = await fetch(`${API_BASE_URL}/surveys`, { method: 'DELETE' });\r\n    if (!response.ok) throw new Error('Failed to delete all surveys');\r\n  }\r\n\r\n  // Export survey data\r\n  public async exportSurveyData(\r\n    surveyId: string,\r\n    format: 'csv' | 'json' = 'csv'\r\n  ): Promise<Blob> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/export?format=${format}`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to export survey data');\r\n    }\r\n\r\n    return await response.blob();\r\n  }\r\n\r\n  // Health check\r\n  public async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const response = await fetch(`${API_BASE_URL}/health`);\r\n      return response.ok;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\nexport default BackendService;\r\n"],"names":["SpecialtyMappingService","constructor","storageService","MAPPINGS_KEY","GROUPS_KEY","LEARNED_MAPPINGS_KEY","specialtyCache","Map","cacheExpiry","CACHE_TTL","SYNONYMS","this","saveMapping","mapping","payload","standardizedName","sourceSpecialties","map","s","specialty","originalName","surveySource","fetch","method","headers","body","JSON","stringify","getAllMappings","res","ok","Error","json","error","console","getUnmappedSpecialties","log","backendService","BackendService","getInstance","surveys","getAllSurveys","length","mappings","unmappedSpecialties","mappedNames","Set","forEach","add","toLowerCase","source","Array","from","batchSize","i","batch","slice","concat","Math","floor","ceil","batchPromises","async","survey","id","rows","getSurveyData","page","limit","counts","row","index","Object","keys","possibleSpecialtyColumns","colName","trim","key","set","get","entries","type","surveyProvider","Promise","all","_ref","count","has","push","name","frequency","autoMapSpecialties","config","unmapped","existingMappings","newMappings","failedMappings","batches","batchIndex","processSpecialtyWithRetry","allSettled","result","_result$reason","status","value","reason","message","warn","maxRetries","attempt","bestMatch","findBestMatch","confidence","confidenceThreshold","find","m","crypto","randomUUID","mappingId","resolve","setTimeout","pow","findSuggestedMatches","calculateConfidence","filter","match","sort","a","b","useFuzzyMatching","arguments","undefined","useSynonyms","maxConfidence","specialtyLower","standardizedLower","getLearnedMapping","then","learnedMapping","includes","synonyms","isSpecialtyMatch","some","syn","isStandardizedMatch","max","similarity","stringSimilarity","sourceLower","sourceSimilarity","saveGroup","group","groups","getAllGroups","existingIndex","findIndex","g","_objectSpread","updatedAt","Date","now","createdAt","storeSurveyData","metadata","totalRows","uniqueSpecialties","uniqueProviderTypes","uniqueRegions","columnMappings","_unused","deleteGroup","groupId","filteredGroups","getMappings","getItem","createMapping","saveLearningData","updateMapping","updates","updatedMapping","deleteMapping","clearAllMappings","setItem","suggestMappings","suggestions","maxSimilarity","standardizedSimilarity","calculateSimilarity","suggestion","str1","str2","createGroup","selectedSpecialties","replace","generateMappingSuggestions","useExistingMappings","normalizeString","str","normalized","normalized1","normalized2","foundMatch","matched","_ref2","_ref3","specialties","totalConfidence","comparisons","j","correctedName","learnedMappings","getLearnedMappings","removeLearnedMapping","API_BASE_URL","instance","getSurveyMeta","surveyId","response","uploadSurvey","file","surveyName","surveyYear","surveyType","onProgress","formData","FormData","append","toString","xhr","XMLHttpRequest","reject","open","onload","parse","responseText","rowCount","err","statusText","onerror","upload","onprogress","event","lengthComputable","percent","round","loaded","total","send","_survey$rowCount","_survey$specialtyCoun","_survey$dataPoints","year","uploadDate","row_count","specialtyCount","specialty_count","dataPoints","data_points","colorAccent","filters","options","params","URLSearchParams","providerType","region","String","data","pagination","Number","pages","getAvailableFiltersForSurvey","deleteSurvey","deleteAllSurveys","exportSurveyData","format","blob","healthCheck"],"sourceRoot":""}