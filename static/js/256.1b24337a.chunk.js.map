{"version":3,"file":"static/js/256.1b24337a.chunk.js","mappings":"yLAKA,MAAMA,EAAeC,CAAAA,SAAAA,aAAAA,WAAAA,qCAAAA,qBAAAA,EAAAA,qBAAAA,EAAAA,qBAAAA,EAAAA,cAAAA,GAAYC,mBAAqB,4BAEtD,MAAMC,EAGIC,WAAAA,GAAe,CAEvB,kBAAcC,GAIZ,OAHKF,EAAeG,WAClBH,EAAeG,SAAW,IAAIH,GAEzBA,EAAeG,QACxB,CAGA,mBAAaC,CAAcC,GACzB,MAAMC,QAAiBC,MAAM,GAADC,OAAIX,EAAY,YAAAW,OAAWH,EAAQ,UAC/D,IAAKC,EAASG,GAAI,MAAM,IAAIC,MAAM,mCAClC,aAAaJ,EAASK,MACxB,CAGA,kBAAaC,CACXC,EACAC,EACAC,EACAC,EACAC,GAEA,MAAMC,EAAW,IAAIC,SACrBD,EAASE,OAAO,OAAQP,GACxBK,EAASE,OAAO,OAAQN,GACxBI,EAASE,OAAO,OAAQL,EAAWM,YACnCH,EAASE,OAAO,OAAQJ,GAGxB,MAAMM,EAAM,IAAIC,eAwBhB,OAvBgB,IAAIC,QAAgD,CAACC,EAASC,KAC5EJ,EAAIK,KAAK,OAAO,GAADnB,OAAKX,EAAY,YAChCyB,EAAIM,OAAS,KACX,GAAIN,EAAIO,QAAU,KAAOP,EAAIO,OAAS,IACpC,IACE,MAAMC,EAASC,KAAKC,MAAMV,EAAIW,cAC9BR,EAAQ,CAAEpB,SAAUyB,EAAOzB,SAAU6B,SAAUJ,EAAOI,UACxD,CAAE,MAAOC,GACPT,EAAO,IAAIhB,MAAM,2BACnB,MAEAgB,EAAO,IAAIhB,MAAM,kBAADF,OAAmBc,EAAIO,OAAM,KAAArB,OAAIc,EAAIc,eAGzDd,EAAIe,QAAU,IAAMX,EAAO,IAAIhB,MAAM,gCACrCY,EAAIgB,OAAOC,WAAcC,IACvB,IAAKvB,IAAeuB,EAAMC,iBAAkB,OAC5C,MAAMC,EAAUC,KAAKC,MAAOJ,EAAMK,OAASL,EAAMM,MAAS,KAC1D7B,EAAWyB,IAEbpB,EAAIyB,KAAK7B,IAIb,CAGA,mBAAa8B,GACX,MAAM1C,QAAiBC,MAAM,GAADC,OAAIX,EAAY,aAE5C,IAAKS,EAASG,GACZ,MAAM,IAAIC,MAAM,2BAMlB,aAHsBJ,EAASK,QAGhBsC,IAAKC,IAAW,IAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,EAAA,MAAM,CACnCC,GAAIP,EAAOO,GACXC,KAAMR,EAAOQ,KACbC,KAAMT,EAAOS,KAAKtC,WAClBuC,KAAMV,EAAOU,KACbC,WAAYX,EAAOW,WACnB3B,SAA6C,QAArCiB,EAAiB,QAAjBC,EAAEF,EAAOhB,gBAAQ,IAAAkB,EAAAA,EAAIF,EAAOY,iBAAS,IAAAX,EAAAA,EAAI,EACjDY,eAA+D,QAAjDV,EAAuB,QAAvBC,EAAEJ,EAAOa,sBAAc,IAAAT,EAAAA,EAAIJ,EAAOc,uBAAe,IAAAX,EAAAA,EAAI,EACnEY,WAAmD,QAAzCV,EAAmB,QAAnBC,EAAEN,EAAOe,kBAAU,IAAAT,EAAAA,EAAIN,EAAOgB,mBAAW,IAAAX,EAAAA,EAAI,EACvDY,YAAajB,EAAOiB,aAAe,UACnCC,SAAUlB,EAAOkB,WAErB,CAKA,mBAAaC,CACXhE,EACAiE,EAKAC,GAEA,MAAMC,EAAS,IAAIC,gBACR,OAAPH,QAAO,IAAPA,GAAAA,EAASI,WAAWF,EAAOpD,OAAO,YAAakD,EAAQI,WAChD,OAAPJ,QAAO,IAAPA,GAAAA,EAASK,cAAcH,EAAOpD,OAAO,eAAgBkD,EAAQK,cACtD,OAAPL,QAAO,IAAPA,GAAAA,EAASM,QAAQJ,EAAOpD,OAAO,SAAUkD,EAAQM,QAC1C,OAAPL,QAAO,IAAPA,GAAAA,EAASM,MAAML,EAAOpD,OAAO,OAAQ0D,OAAOP,EAAQM,OAC7C,OAAPN,QAAO,IAAPA,GAAAA,EAASQ,OAAOP,EAAOpD,OAAO,QAAS0D,OAAOP,EAAQQ,QAE1D,MAAMzE,QAAiBC,MAAM,GAADC,OAAIX,EAAY,YAAAW,OAAWH,EAAQ,UAAAG,OAASgE,EAAOnD,aAE/E,IAAKf,EAASG,GACZ,MAAM,IAAIC,MAAM,+BAGlB,MAAMsE,QAAa1E,EAASK,OAMtBsE,GAFaD,EAAKA,MAAQA,GAER/B,IAAKiC,IAAQC,EAAAA,EAAAA,GAAA,GAAWD,IAShD,MAAO,CAAED,OAAMG,WARIJ,EAAKI,WACpB,CACEP,KAAMQ,OAAOL,EAAKI,WAAWP,OAAS,EACtCE,MAAOM,OAAOL,EAAKI,WAAWL,QAAUE,EAAKK,OAC7CxC,MAAOuC,OAAOL,EAAKI,WAAWtC,QAAUmC,EAAKK,OAC7CC,MAAOF,OAAOL,EAAKI,WAAWG,QAAU,QAE1CC,EAEN,CAGA,kCAAaC,CAA6BpF,GAKxC,MAAMC,QAAiBC,MAAM,GAADC,OAAIX,EAAY,YAAAW,OAAWH,EAAQ,aAE/D,IAAKC,EAASG,GACZ,MAAM,IAAIC,MAAM,2BAGlB,aAAaJ,EAASK,MACxB,CAGA,kBAAa+E,CAAarF,GAKxB,WAJuBE,MAAM,GAADC,OAAIX,EAAY,YAAAW,OAAWH,GAAY,CACjEsF,OAAQ,YAGIlF,GACZ,MAAM,IAAIC,MAAM,0BAEpB,CAGA,sBAAakF,GAEX,WADuBrF,MAAM,GAADC,OAAIX,EAAY,YAAY,CAAE8F,OAAQ,YACpDlF,GAAI,MAAM,IAAIC,MAAM,+BACpC,CAGA,sBAAamF,CACXxF,GAEgB,IADhByF,EAAsBC,UAAAT,OAAA,QAAAE,IAAAO,UAAA,GAAAA,UAAA,GAAG,MAEzB,MAAMzF,QAAiBC,MAAM,GAADC,OAAIX,EAAY,YAAAW,OAAWH,EAAQ,mBAAAG,OAAkBsF,IAEjF,IAAKxF,EAASG,GACZ,MAAM,IAAIC,MAAM,gCAGlB,aAAaJ,EAAS0F,MACxB,CAGA,iBAAaC,GACX,IAEE,aADuB1F,MAAM,GAADC,OAAIX,EAAY,aAC5BY,EAClB,CAAE,MAAAyF,GACA,OAAO,CACT,CACF,EAvLIlG,EACWG,cAAQ,EAyLzB,S","sources":["services/BackendService.ts"],"sourcesContent":["import { \r\n  ISurveyData, \r\n  ISurveyRow \r\n} from '../types/survey';\r\n\r\nconst API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:3001/api';\r\n\r\nclass BackendService {\r\n  private static instance: BackendService;\r\n\r\n  private constructor() {}\r\n\r\n  public static getInstance(): BackendService {\r\n    if (!BackendService.instance) {\r\n      BackendService.instance = new BackendService();\r\n    }\r\n    return BackendService.instance;\r\n  }\r\n\r\n  // Get survey metadata (includes original columns list)\r\n  public async getSurveyMeta(surveyId: string): Promise<{ columns?: string[] }> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/meta`);\r\n    if (!response.ok) throw new Error('Failed to fetch survey metadata');\r\n    return await response.json();\r\n  }\r\n\r\n  // Upload a survey file\r\n  public async uploadSurvey(\r\n    file: File,\r\n    surveyName: string,\r\n    surveyYear: number,\r\n    surveyType: string,\r\n    onProgress?: (percent: number) => void\r\n  ): Promise<{ surveyId: string; rowCount: number }> {\r\n    const formData = new FormData();\r\n    formData.append('file', file);\r\n    formData.append('name', surveyName);\r\n    formData.append('year', surveyYear.toString());\r\n    formData.append('type', surveyType);\r\n\r\n    // Use XHR to report real upload progress\r\n    const xhr = new XMLHttpRequest();\r\n    const promise = new Promise<{ surveyId: string; rowCount: number }>((resolve, reject) => {\r\n      xhr.open('POST', `${API_BASE_URL}/upload`);\r\n      xhr.onload = () => {\r\n        if (xhr.status >= 200 && xhr.status < 300) {\r\n          try {\r\n            const result = JSON.parse(xhr.responseText);\r\n            resolve({ surveyId: result.surveyId, rowCount: result.rowCount });\r\n          } catch (err) {\r\n            reject(new Error('Invalid server response'));\r\n          }\r\n        } else {\r\n          reject(new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`));\r\n        }\r\n      };\r\n      xhr.onerror = () => reject(new Error('Network error during upload'));\r\n      xhr.upload.onprogress = (event) => {\r\n        if (!onProgress || !event.lengthComputable) return;\r\n        const percent = Math.round((event.loaded / event.total) * 100);\r\n        onProgress(percent);\r\n      };\r\n      xhr.send(formData);\r\n    });\r\n\r\n    return promise;\r\n  }\r\n\r\n  // Get all surveys\r\n  public async getAllSurveys(): Promise<ISurveyData[]> {\r\n    const response = await fetch(`${API_BASE_URL}/surveys`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to fetch surveys');\r\n    }\r\n\r\n    const surveys = await response.json();\r\n    \r\n    // Transform backend format to frontend format\r\n    return surveys.map((survey: any) => ({\r\n      id: survey.id,\r\n      name: survey.name,\r\n      year: survey.year.toString(),\r\n      type: survey.type,\r\n      uploadDate: survey.uploadDate,\r\n      rowCount: survey.rowCount ?? survey.row_count ?? 0,\r\n      specialtyCount: survey.specialtyCount ?? survey.specialty_count ?? 0,\r\n      dataPoints: survey.dataPoints ?? survey.data_points ?? 0,\r\n      colorAccent: survey.colorAccent || '#6366F1',\r\n      metadata: survey.metadata\r\n    }));\r\n  }\r\n\r\n  // Get survey data with filters\r\n  // CRITICAL: Always pass options.limit for large datasets to avoid missing data\r\n  // See docs/ALLERGY_IMMUNOLOGY_FIX.md for details on the 100-row default limit issue\r\n  public async getSurveyData(\r\n    surveyId: string,\r\n    filters?: {\r\n      specialty?: string;\r\n      providerType?: string;\r\n      region?: string;\r\n    },\r\n    options?: { page?: number; limit?: number }\r\n  ): Promise<{ rows: ISurveyRow[]; pagination?: { page: number; limit: number; total: number; pages: number } }>{\r\n    const params = new URLSearchParams();\r\n    if (filters?.specialty) params.append('specialty', filters.specialty);\r\n    if (filters?.providerType) params.append('providerType', filters.providerType);\r\n    if (filters?.region) params.append('region', filters.region);\r\n    if (options?.page) params.append('page', String(options.page));\r\n    if (options?.limit) params.append('limit', String(options.limit));\r\n\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/data?${params.toString()}`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to fetch survey data');\r\n    }\r\n\r\n    const data = await response.json();\r\n    \r\n    // Transform backend format to frontend format\r\n    // Backend returns { data: [...], pagination: {...} }\r\n    const surveyData = data.data || data;\r\n    // Keep all keys so the grid can render every original column.\r\n    const rows = surveyData.map((row: any) => ({ ...row }));\r\n    const pagination = data.pagination\r\n      ? {\r\n          page: Number(data.pagination.page) || 1,\r\n          limit: Number(data.pagination.limit) || rows.length,\r\n          total: Number(data.pagination.total) || rows.length,\r\n          pages: Number(data.pagination.pages) || 1,\r\n        }\r\n      : undefined;\r\n    return { rows, pagination };\r\n  }\r\n\r\n  // Get available filters\r\n  public async getAvailableFiltersForSurvey(surveyId: string): Promise<{\r\n    specialties: string[];\r\n    providerTypes: string[];\r\n    regions: string[];\r\n  }> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/filters`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to fetch filters');\r\n    }\r\n\r\n    return await response.json();\r\n  }\r\n\r\n  // Delete a survey\r\n  public async deleteSurvey(surveyId: string): Promise<void> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}`, {\r\n      method: 'DELETE',\r\n    });\r\n\r\n    if (!response.ok) {\r\n      throw new Error('Failed to delete survey');\r\n    }\r\n  }\r\n\r\n  // Delete all surveys\r\n  public async deleteAllSurveys(): Promise<void> {\r\n    const response = await fetch(`${API_BASE_URL}/surveys`, { method: 'DELETE' });\r\n    if (!response.ok) throw new Error('Failed to delete all surveys');\r\n  }\r\n\r\n  // Export survey data\r\n  public async exportSurveyData(\r\n    surveyId: string,\r\n    format: 'csv' | 'json' = 'csv'\r\n  ): Promise<Blob> {\r\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/export?format=${format}`);\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to export survey data');\r\n    }\r\n\r\n    return await response.blob();\r\n  }\r\n\r\n  // Health check\r\n  public async healthCheck(): Promise<boolean> {\r\n    try {\r\n      const response = await fetch(`${API_BASE_URL}/health`);\r\n      return response.ok;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\nexport default BackendService;\r\n"],"names":["API_BASE_URL","process","REACT_APP_API_URL","BackendService","constructor","getInstance","instance","getSurveyMeta","surveyId","response","fetch","concat","ok","Error","json","uploadSurvey","file","surveyName","surveyYear","surveyType","onProgress","formData","FormData","append","toString","xhr","XMLHttpRequest","Promise","resolve","reject","open","onload","status","result","JSON","parse","responseText","rowCount","err","statusText","onerror","upload","onprogress","event","lengthComputable","percent","Math","round","loaded","total","send","getAllSurveys","map","survey","_ref","_survey$rowCount","_ref2","_survey$specialtyCoun","_ref3","_survey$dataPoints","id","name","year","type","uploadDate","row_count","specialtyCount","specialty_count","dataPoints","data_points","colorAccent","metadata","getSurveyData","filters","options","params","URLSearchParams","specialty","providerType","region","page","String","limit","data","rows","row","_objectSpread","pagination","Number","length","pages","undefined","getAvailableFiltersForSurvey","deleteSurvey","method","deleteAllSurveys","exportSurveyData","format","arguments","blob","healthCheck","_unused"],"sourceRoot":""}