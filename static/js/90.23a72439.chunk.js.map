{"version":3,"file":"static/js/90.23a72439.chunk.js","mappings":"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","sources":["services/SpecialtyMappingService.ts","services/BackendService.ts"],"sourcesContent":["import { ISpecialtyMapping, ISourceSpecialty, IUnmappedSpecialty, IAutoMappingConfig, ISurveyData, ISpecialtyGroup, IMappingSuggestion } from '../types/specialty';\nimport { stringSimilarity } from 'string-similarity-js';\nimport { LocalStorageService } from './StorageService';\nimport BackendService from './BackendService';\nimport { ISurveyRow } from '../types/survey';\n\nconst API_BASE_URL = 'https://survey-aggregator-backend.azurewebsites.net/api';\n\nexport class SpecialtyMappingService {\n  private readonly MAPPINGS_KEY = 'specialty-mappings';\n  private readonly storageService: LocalStorageService;\n  private readonly GROUPS_KEY = 'specialty_groups';\n  private readonly LEARNED_MAPPINGS_KEY = 'learned-specialty-mappings';\n  \n  // Add caching for performance\n  private specialtyCache = new Map<string, Set<string>>();\n  private cacheExpiry = new Map<string, number>();\n  private readonly CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\n  private readonly SYNONYMS: Record<string, string[]> = {\n    'cardiology': ['heart', 'cardiac', 'cardiovascular'],\n    'orthopedics': ['ortho', 'orthopedic', 'orthopaedic'],\n    'pediatrics': ['peds', 'pediatric', 'children'],\n    'critical care': [\n      'intensivist', \n      'critical care medicine', \n      'critical care/intensivist', \n      'intensive care',\n      'critical care medicine',\n      'cc medicine',\n      'cc/intensivist',\n      'icu'\n    ],\n    'emergency medicine': ['emergency', 'er', 'ed'],\n    'internal medicine': ['internist', 'internal med'],\n    'obstetrics': ['ob/gyn', 'obgyn', 'obstetrics and gynecology', 'obstetrics & gynecology'],\n    'anesthesiology': ['anesthesia', 'anesthetist'],\n    'family medicine': ['family practice', 'family physician', 'family med'],\n    'neurology': ['neurological', 'neuro'],\n    'psychiatry': ['psychiatric', 'mental health'],\n    'radiology': ['radiologist', 'imaging', 'diagnostic radiology'],\n    'surgery': ['surgeon', 'surgical']\n  };\n\n  constructor(storageService: LocalStorageService) {\n    this.storageService = storageService;\n  }\n\n  async saveMapping(mapping: ISpecialtyMapping): Promise<void> {\n    // Persist to backend API\n    const payload = {\n      standardizedName: mapping.standardizedName,\n      sourceSpecialties: mapping.sourceSpecialties.map(s => ({\n        specialty: s.specialty,\n        originalName: s.originalName,\n        surveySource: s.surveySource\n      }))\n    };\n    await fetch(`${API_BASE_URL}/mappings/specialty`, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(payload)\n    });\n  }\n\n  async getAllMappings(): Promise<ISpecialtyMapping[]> {\n    try {\n      const res = await fetch(`${API_BASE_URL}/mappings/specialty`);\n      if (!res.ok) throw new Error('Failed to fetch');\n      const data = await res.json();\n      return data as ISpecialtyMapping[];\n    } catch (error) {\n      console.error('Error fetching specialty mappings:', error);\n      return [];\n    }\n  }\n\n  async getUnmappedSpecialties(): Promise<IUnmappedSpecialty[]> {\n    try {\n      console.log('🔄 Fetching unmapped specialties with caching...');\n      \n      // Get all surveys from backend\n      const backendService = BackendService.getInstance();\n      console.log('📡 Calling backendService.getAllSurveys()...');\n      const surveys = await backendService.getAllSurveys();\n      console.log('📊 Surveys received:', surveys.length, surveys);\n      \n      const mappings = await this.getAllMappings();\n      console.log('🗺️ Existing mappings:', mappings.length);\n      \n      const unmappedSpecialties: IUnmappedSpecialty[] = [];\n      const mappedNames = new Set<string>();\n\n      // Collect all mapped specialty names (both standardized and original names)\n      mappings.forEach(mapping => {\n        mappedNames.add(mapping.standardizedName.toLowerCase());\n        mapping.sourceSpecialties.forEach((source: ISourceSpecialty) => {\n          mappedNames.add(source.specialty.toLowerCase());\n        });\n      });\n      console.log('✅ Mapped names collected:', Array.from(mappedNames));\n\n      // Process surveys in batches for better performance\n      const batchSize = 10;\n\n      for (let i = 0; i < surveys.length; i += batchSize) {\n        const batch = surveys.slice(i, i + batchSize);\n        console.log(`📦 Processing batch ${Math.floor(i / batchSize) + 1}/${Math.ceil(surveys.length / batchSize)}`);\n        \n        const batchPromises = batch.map(async (survey) => {\n          try {\n            // Fetch from backend\n            console.log(`🔍 Fetching data for survey ${survey.id}...`);\n            const { rows } = await backendService.getSurveyData(survey.id, {}, { page: 1, limit: 10000 });\n            console.log(`📋 Survey ${survey.id} returned ${rows.length} rows`);\n            \n            // Extract specialties and count per survey\n            const counts = new Map<string, number>();\n            \n            rows.forEach((row: any, index: number) => {\n              // Log all column names from first row\n              if (index === 0) {\n                console.log('📋 All column names in row:', Object.keys(row));\n              }\n              \n              // Check multiple possible specialty column names\n              const possibleSpecialtyColumns = [\n                'specialty', 'Specialty', 'Provider Type', 'provider_type', \n                'ProviderType', 'specialty_name', 'SpecialtyName', 'specialtyName',\n                'PROVIDER_TYPE', 'SPECIALTY', 'Specialty Type', 'specialty_type'\n              ];\n              \n              let specialty = '';\n              for (const colName of possibleSpecialtyColumns) {\n                if (row[colName] && typeof row[colName] === 'string' && row[colName].trim()) {\n                  specialty = row[colName].trim();\n                  console.log(`✅ Found specialty in column \"${colName}\": ${specialty}`);\n                  break;\n                }\n              }\n              \n              if (specialty) {\n                const key = specialty;\n                counts.set(key, (counts.get(key) || 0) + 1);\n              }\n              \n              // Log first few rows for debugging\n              if (index < 5) {\n                console.log(`Row ${index}:`, { specialty, row });\n              }\n            });\n\n            console.log(`🏥 Found specialties in survey ${survey.id}:`, Array.from(counts.entries()));\n\n            const surveySource = (survey as any).type || (survey as any).surveyProvider || 'Unknown';\n            return { surveySource, counts };\n          } catch (error) {\n            console.error(`❌ Error processing survey ${survey.id}:`, error);\n            return { surveySource: 'Unknown', counts: new Map<string, number>() };\n          }\n        });\n\n        const batchResults = await Promise.all(batchPromises);\n        \n        // Convert per-survey counts into unmapped entries (one per survey source)\n        batchResults.forEach(({ surveySource, counts }) => {\n                      counts.forEach((count, specialty) => {\n              const key = specialty.toLowerCase();\n              if (!mappedNames.has(key)) {\n                unmappedSpecialties.push({\n                  id: `${surveySource}-${specialty}`,\n                  name: specialty,\n                  surveySource,\n                  frequency: count\n                });\n              }\n            });\n        });\n      }\n\n      console.log(`✅ Found ${unmappedSpecialties.length} unmapped specialties:`, unmappedSpecialties);\n      return unmappedSpecialties;\n    } catch (error) {\n      console.error('❌ Error getting unmapped specialties:', error);\n      return [];\n    }\n  }\n\n  async autoMapSpecialties(config: IAutoMappingConfig): Promise<ISpecialtyMapping[]> {\n    console.log('🚀 Starting auto-mapping with retry logic...');\n    \n    const unmapped = await this.getUnmappedSpecialties();\n    const existingMappings = await this.getAllMappings();\n    const newMappings: ISpecialtyMapping[] = [];\n    const failedMappings: Array<{ specialty: string; error: string }> = [];\n\n    // Process in batches with retry logic\n    const batchSize = 50;\n    const batches = [];\n    \n    for (let i = 0; i < unmapped.length; i += batchSize) {\n      batches.push(unmapped.slice(i, i + batchSize));\n    }\n\n    for (let batchIndex = 0; batchIndex < batches.length; batchIndex++) {\n      const batch = batches[batchIndex];\n      console.log(`📦 Processing auto-mapping batch ${batchIndex + 1}/${batches.length}`);\n      \n      const batchPromises = batch.map(async (specialty) => {\n        return this.processSpecialtyWithRetry(specialty, existingMappings, config, 3);\n      });\n\n      const batchResults = await Promise.allSettled(batchPromises);\n      \n      batchResults.forEach((result, index) => {\n        const specialty = batch[index];\n        if (result.status === 'fulfilled' && result.value) {\n          newMappings.push(result.value);\n        } else {\n          failedMappings.push({\n            specialty: specialty.name,\n            error: result.status === 'rejected' ? result.reason?.message || 'Unknown error' : 'Failed to process'\n          });\n        }\n      });\n    }\n\n    console.log(`✅ Auto-mapping completed: ${newMappings.length} successful, ${failedMappings.length} failed`);\n    \n    if (failedMappings.length > 0) {\n      console.warn('⚠️ Failed mappings:', failedMappings);\n    }\n\n    return newMappings;\n  }\n\n  private async processSpecialtyWithRetry(\n    specialty: IUnmappedSpecialty,\n    existingMappings: ISpecialtyMapping[],\n    config: IAutoMappingConfig,\n    maxRetries: number\n  ): Promise<ISpecialtyMapping | null> {\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        const bestMatch = this.findBestMatch(specialty.name, existingMappings, config);\n\n        if (bestMatch && bestMatch.confidence >= config.confidenceThreshold) {\n          const mapping = existingMappings.find(m => m.standardizedName === bestMatch.standardizedName);\n          if (mapping) {\n            mapping.sourceSpecialties.push({\n              id: crypto.randomUUID(),\n              specialty: specialty.name,\n              originalName: specialty.name,\n              surveySource: specialty.surveySource,\n              mappingId: mapping.id\n            });\n            await this.saveMapping(mapping);\n            return mapping;\n          }\n        }\n        return null; // No match found, not an error\n      } catch (error) {\n        console.error(`Attempt ${attempt} failed for specialty ${specialty.name}:`, error);\n        if (attempt === maxRetries) {\n          throw error;\n        }\n        // Wait before retry (exponential backoff)\n        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\n      }\n    }\n    return null;\n  }\n\n  private findSuggestedMatches(\n    specialty: string,\n    existingMappings: ISpecialtyMapping[]\n  ): Array<{ standardizedName: string; confidence: number }> {\n    return existingMappings\n      .map(mapping => ({\n        standardizedName: mapping.standardizedName,\n        confidence: this.calculateConfidence(specialty, mapping)\n      }))\n      .filter(match => match.confidence > 0.3)\n      .sort((a, b) => b.confidence - a.confidence)\n      .slice(0, 5);\n  }\n\n  private findBestMatch(\n    specialty: string,\n    existingMappings: ISpecialtyMapping[],\n    config: IAutoMappingConfig\n  ): { standardizedName: string; confidence: number } | null {\n    const matches = existingMappings\n      .map(mapping => ({\n        standardizedName: mapping.standardizedName,\n        confidence: this.calculateConfidence(\n          specialty,\n          mapping,\n          config.useFuzzyMatching,\n          true\n        )\n      }))\n      .filter(match => match.confidence >= config.confidenceThreshold)\n      .sort((a, b) => b.confidence - a.confidence);\n\n    return matches[0] || null;\n  }\n\n  private calculateConfidence(\n    specialty: string,\n    mapping: ISpecialtyMapping,\n    useFuzzyMatching: boolean = true,\n    useSynonyms: boolean = true\n  ): number {\n    let maxConfidence = 0;\n    const specialtyLower = specialty.toLowerCase();\n    const standardizedLower = mapping.standardizedName.toLowerCase();\n\n    // Check learned mappings first\n    this.getLearnedMapping(specialty).then(learnedMapping => {\n      if (learnedMapping && learnedMapping === mapping.standardizedName) {\n        return 1.0;\n      }\n    });\n\n    // Direct match check\n    if (specialtyLower === standardizedLower) {\n      return 1.0;\n    }\n\n    // Critical Care specific matching\n    if (specialtyLower.includes('critical care') || \n        specialtyLower.includes('intensivist') || \n        standardizedLower.includes('critical care') || \n        standardizedLower.includes('intensivist')) {\n      // If both terms are related to critical care, give very high confidence\n      if ((specialtyLower.includes('critical care') || specialtyLower.includes('intensivist')) &&\n          (standardizedLower.includes('critical care') || standardizedLower.includes('intensivist'))) {\n        return 0.95; // Very high confidence for critical care variations\n      }\n    }\n\n    // Synonym check\n    if (useSynonyms) {\n      for (const [key, synonyms] of Object.entries(this.SYNONYMS)) {\n        const isSpecialtyMatch = specialtyLower.includes(key) || \n          synonyms.some(syn => specialtyLower.includes(syn));\n        const isStandardizedMatch = standardizedLower.includes(key) || \n          synonyms.some(syn => standardizedLower.includes(syn));\n        \n        if (isSpecialtyMatch && isStandardizedMatch) {\n          maxConfidence = Math.max(maxConfidence, 0.9);\n        }\n      }\n    }\n\n    // String similarity check\n    if (useFuzzyMatching) {\n      const similarity = stringSimilarity(specialtyLower, standardizedLower);\n      maxConfidence = Math.max(maxConfidence, similarity);\n\n      // Check against all source names\n      for (const source of mapping.sourceSpecialties) {\n        const sourceLower = source.specialty.toLowerCase();\n        \n        // Direct match with source\n        if (specialtyLower === sourceLower) {\n          return 1.0;\n        }\n        \n        const sourceSimilarity = stringSimilarity(specialtyLower, sourceLower);\n        maxConfidence = Math.max(maxConfidence, sourceSimilarity);\n\n        // Additional check for partial matches\n        if (specialtyLower.includes(sourceLower) || sourceLower.includes(specialtyLower)) {\n          maxConfidence = Math.max(maxConfidence, 0.85);\n        }\n      }\n    }\n\n    return maxConfidence;\n  }\n\n  // Group management methods\n  async saveGroup(group: ISpecialtyGroup): Promise<void> {\n    const groups = await this.getAllGroups();\n    const existingIndex = groups.findIndex(g => g.id === group.id);\n    \n    if (existingIndex >= 0) {\n      groups[existingIndex] = {\n        ...group,\n        updatedAt: new Date()\n      };\n    } else {\n      const now = new Date();\n      groups.push({\n        ...group,\n        createdAt: now,\n        updatedAt: now\n      });\n    }\n\n    await this.storageService.storeSurveyData<ISpecialtyGroup>({\n      id: this.GROUPS_KEY,\n      metadata: { \n        type: 'specialty_groups',\n        totalRows: groups.length,\n        uniqueSpecialties: [],\n        uniqueProviderTypes: [],\n        uniqueRegions: [],\n        columnMappings: {}\n      },\n      rows: groups\n    });\n  }\n\n  async getAllGroups(): Promise<ISpecialtyGroup[]> {\n    try {\n      const result = await this.storageService.getSurveyData<ISpecialtyGroup>(this.GROUPS_KEY);\n      return result.rows;\n    } catch {\n      return [];\n    }\n  }\n\n  async deleteGroup(groupId: string): Promise<void> {\n    const groups = await this.getAllGroups();\n    const filteredGroups = groups.filter(g => g.id !== groupId);\n    \n    await this.storageService.storeSurveyData<ISpecialtyGroup>({\n      id: this.GROUPS_KEY,\n      metadata: { \n        type: 'specialty_groups',\n        totalRows: filteredGroups.length,\n        uniqueSpecialties: [],\n        uniqueProviderTypes: [],\n        uniqueRegions: [],\n        columnMappings: {}\n      },\n      rows: filteredGroups\n    });\n  }\n\n  async getMappings(): Promise<ISpecialtyMapping[]> {\n    try {\n      const mappings = await this.storageService.getItem(this.MAPPINGS_KEY) as ISpecialtyMapping[];\n      return mappings || [];\n    } catch (error) {\n      console.error('Error fetching specialty mappings:', error);\n      return [];\n    }\n  }\n\n  async createMapping(standardizedName: string, sourceSpecialties: ISourceSpecialty[]): Promise<ISpecialtyMapping> {\n    const mapping: ISpecialtyMapping = {\n      id: crypto.randomUUID(),\n      standardizedName,\n      sourceSpecialties: sourceSpecialties.map(s => ({\n        ...s,\n        mappingId: crypto.randomUUID()\n      })),\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    // Learn from new mappings\n    for (const specialty of sourceSpecialties) {\n      if (specialty.specialty !== standardizedName) {\n        await this.saveLearningData(specialty.specialty, standardizedName);\n      }\n    }\n\n    await this.saveMapping(mapping);\n    return mapping;\n  }\n\n  async updateMapping(mappingId: string, updates: Partial<ISpecialtyMapping>): Promise<ISpecialtyMapping> {\n    const mappings = await this.getMappings();\n    const index = mappings.findIndex(m => m.id === mappingId);\n    \n    if (index === -1) {\n      throw new Error(`Mapping with id ${mappingId} not found`);\n    }\n\n    // Learn from this correction\n    if (updates.standardizedName && updates.standardizedName !== mappings[index].standardizedName) {\n      await this.saveLearningData(mappings[index].standardizedName, updates.standardizedName);\n    }\n\n    const updatedMapping = {\n      ...mappings[index],\n      ...updates,\n      updatedAt: new Date()\n    };\n\n    // Update via backend API\n    await fetch(`${API_BASE_URL}/mappings/specialty/${mappingId}`, {\n      method: 'PUT',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(updatedMapping)\n    });\n\n    return updatedMapping;\n  }\n\n  async deleteMapping(mappingId: string): Promise<void> {\n    // Delete via backend API\n    await fetch(`${API_BASE_URL}/mappings/specialty/${mappingId}`, {\n      method: 'DELETE'\n    });\n  }\n\n  async clearAllMappings(): Promise<void> {\n    // Clear via backend API\n    await fetch(`${API_BASE_URL}/mappings/specialty`, {\n      method: 'DELETE'\n    });\n    await this.storageService.setItem(this.LEARNED_MAPPINGS_KEY, {});\n  }\n\n  async suggestMappings(specialty: IUnmappedSpecialty, config: IAutoMappingConfig): Promise<ISpecialtyMapping[]> {\n    const mappings = await this.getMappings();\n    const suggestions: Array<{ mapping: ISpecialtyMapping; similarity: number }> = [];\n\n    for (const mapping of mappings) {\n      let maxSimilarity = 0;\n\n      // Compare with standardized name\n      const standardizedSimilarity = this.calculateSimilarity(\n        specialty.name,\n        mapping.standardizedName,\n        config\n      );\n      maxSimilarity = Math.max(maxSimilarity, standardizedSimilarity);\n\n      // Compare with source specialties\n      for (const source of mapping.sourceSpecialties) {\n        const sourceSimilarity = this.calculateSimilarity(\n          specialty.name,\n          source.specialty,\n          config\n        );\n        maxSimilarity = Math.max(maxSimilarity, sourceSimilarity);\n      }\n\n      if (maxSimilarity >= config.confidenceThreshold) {\n        suggestions.push({ mapping, similarity: maxSimilarity });\n      }\n    }\n\n    return suggestions\n      .sort((a, b) => b.similarity - a.similarity)\n      .map(suggestion => suggestion.mapping);\n  }\n\n  private calculateSimilarity(str1: string, str2: string, config: IAutoMappingConfig): number {\n    // Always case-insensitive comparison\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n\n    if (str1 === str2) return 1;\n    if (!config.useFuzzyMatching) return 0;\n\n    return stringSimilarity(str1, str2);\n  }\n\n  async createGroup(standardizedName: string, selectedSpecialties: IUnmappedSpecialty[]): Promise<ISpecialtyGroup> {\n    const now = new Date();\n    const group: ISpecialtyGroup = {\n      id: `${standardizedName}`.toLowerCase().replace(/\\s+/g, '-'),\n      standardizedName,\n      selectedSpecialties,\n      createdAt: now,\n      updatedAt: now\n    };\n    \n    await this.saveGroup(group);\n    return group;\n  }\n\n  async generateMappingSuggestions(config: IAutoMappingConfig): Promise<IMappingSuggestion[]> {\n    const unmappedSpecialties = await this.getUnmappedSpecialties();\n    const existingMappings = config.useExistingMappings ? await this.getAllMappings() : [];\n    const suggestions: IMappingSuggestion[] = [];\n\n    // Group specialties by similar names\n    const groups = new Map<string, Array<{ name: string; surveySource: string }>>();\n\n    // Helper function to normalize strings for comparison\n    const normalizeString = (str: string): string => {\n      let normalized = str.toLowerCase();\n      if (!config.useFuzzyMatching) {\n        // Only basic normalization if fuzzy matching is disabled\n        return normalized.trim();\n      }\n      // More aggressive normalization for fuzzy matching\n      normalized = normalized\n        .replace(/[^a-z0-9\\s]/g, '') // Remove special characters\n        .replace(/\\s+/g, ' ') // Normalize whitespace\n        .trim();\n      return normalized;\n    };\n\n    // Function to calculate similarity between two strings\n    const calculateSimilarity = (str1: string, str2: string): number => {\n      const normalized1 = normalizeString(str1);\n      const normalized2 = normalizeString(str2);\n      \n      if (!config.useFuzzyMatching) {\n        // Exact match when fuzzy matching is disabled\n        return normalized1 === normalized2 ? 1 : 0;\n      }\n      \n      return stringSimilarity(normalized1, normalized2);\n    };\n\n    // First pass: group by exact matches\n    unmappedSpecialties.forEach(specialty => {\n      let foundMatch = false;\n      \n      // Check against existing mappings first\n      if (config.useExistingMappings) {\n        for (const mapping of existingMappings) {\n          const similarity = calculateSimilarity(specialty.name, mapping.standardizedName);\n          if (similarity >= config.confidenceThreshold) {\n            const key = mapping.standardizedName;\n            const group = groups.get(key) || [];\n            group.push({ name: specialty.name, surveySource: specialty.surveySource as any });\n            groups.set(key, group);\n            foundMatch = true;\n            break;\n          }\n        }\n      }\n\n      if (!foundMatch) {\n        // Try to match with other unmapped specialties\n        let matched = false;\n        // Convert Map.entries() to Array to avoid iterator issues\n        Array.from(groups.entries()).forEach(([key, group]) => {\n          if (!matched) {\n            const similarity = calculateSimilarity(specialty.name, key);\n            if (similarity >= config.confidenceThreshold) {\n              group.push({ name: specialty.name, surveySource: specialty.surveySource as any });\n              matched = true;\n            }\n          }\n        });\n\n        if (!matched) {\n          // Create new group\n          groups.set(specialty.name, [{ name: specialty.name, surveySource: specialty.surveySource as any }]);\n        }\n      }\n    });\n\n    // Convert groups to suggestions\n    // Convert Map.entries() to Array to avoid iterator issues\n    Array.from(groups.entries()).forEach(([standardizedName, specialties]) => {\n      if (specialties.length > 0) {\n        // Calculate average confidence for the group\n        let totalConfidence = 0;\n        let comparisons = 0;\n\n        for (let i = 0; i < specialties.length; i++) {\n          for (let j = i + 1; j < specialties.length; j++) {\n            totalConfidence += calculateSimilarity(specialties[i].name, specialties[j].name);\n            comparisons++;\n          }\n        }\n\n        const confidence = comparisons > 0 \n          ? totalConfidence / comparisons \n          : (specialties.length === 1 ? 1 : 0);\n\n        suggestions.push({\n          standardizedName,\n          confidence,\n          specialties\n        });\n      }\n    });\n\n    return suggestions.sort((a, b) => b.confidence - a.confidence);\n  }\n\n  private async saveLearningData(originalName: string, correctedName: string): Promise<void> {\n    try {\n      const learnedMappings = await this.storageService.getItem(this.LEARNED_MAPPINGS_KEY) || {};\n      learnedMappings[originalName.toLowerCase()] = correctedName;\n      await this.storageService.setItem(this.LEARNED_MAPPINGS_KEY, learnedMappings);\n    } catch (error) {\n      console.error('Error saving learning data:', error);\n    }\n  }\n\n  private async getLearnedMapping(specialty: string): Promise<string | null> {\n    try {\n      const learnedMappings = await this.storageService.getItem(this.LEARNED_MAPPINGS_KEY) || {};\n      return learnedMappings[specialty.toLowerCase()] || null;\n    } catch (error) {\n      console.error('Error getting learned mapping:', error);\n      return null;\n    }\n  }\n\n  async getLearnedMappings(): Promise<Record<string, string>> {\n    try {\n      return await this.storageService.getItem(this.LEARNED_MAPPINGS_KEY) || {};\n    } catch (error) {\n      console.error('Error getting learned mappings:', error);\n      return {};\n    }\n  }\n\n  async removeLearnedMapping(originalName: string): Promise<void> {\n    try {\n      const learnedMappings = await this.getLearnedMappings();\n      delete learnedMappings[originalName.toLowerCase()];\n      await this.storageService.setItem(this.LEARNED_MAPPINGS_KEY, learnedMappings);\n    } catch (error) {\n      console.error('Error removing learned mapping:', error);\n    }\n  }\n} ","import { \n  ISurveyData, \n  ISurveyRow \n} from '../types/survey';\n\nconst API_BASE_URL = 'https://survey-aggregator-backend.azurewebsites.net/api';\n\nclass BackendService {\n  private static instance: BackendService;\n\n  private constructor() {}\n\n  public static getInstance(): BackendService {\n    if (!BackendService.instance) {\n      BackendService.instance = new BackendService();\n    }\n    return BackendService.instance;\n  }\n\n  // Get survey metadata (includes original columns list)\n  public async getSurveyMeta(surveyId: string): Promise<{ columns?: string[] }> {\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/meta`);\n    if (!response.ok) throw new Error('Failed to fetch survey metadata');\n    return await response.json();\n  }\n\n  // Upload a survey file\n  public async uploadSurvey(\n    file: File,\n    surveyName: string,\n    surveyYear: number,\n    surveyType: string,\n    onProgress?: (percent: number) => void\n  ): Promise<{ surveyId: string; rowCount: number }> {\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('name', surveyName);\n    formData.append('year', surveyYear.toString());\n    formData.append('type', surveyType);\n\n    // Use XHR to report real upload progress\n    const xhr = new XMLHttpRequest();\n    const promise = new Promise<{ surveyId: string; rowCount: number }>((resolve, reject) => {\n      xhr.open('POST', `${API_BASE_URL}/upload`);\n      xhr.onload = () => {\n        if (xhr.status >= 200 && xhr.status < 300) {\n          try {\n            const result = JSON.parse(xhr.responseText);\n            resolve({ surveyId: result.surveyId, rowCount: result.rowCount });\n          } catch (err) {\n            reject(new Error('Invalid server response'));\n          }\n        } else {\n          reject(new Error(`Upload failed: ${xhr.status} ${xhr.statusText}`));\n        }\n      };\n      xhr.onerror = () => reject(new Error('Network error during upload'));\n      xhr.upload.onprogress = (event) => {\n        if (!onProgress || !event.lengthComputable) return;\n        const percent = Math.round((event.loaded / event.total) * 100);\n        onProgress(percent);\n      };\n      xhr.send(formData);\n    });\n\n    return promise;\n  }\n\n  // Get all surveys\n  public async getAllSurveys(): Promise<ISurveyData[]> {\n    const response = await fetch(`${API_BASE_URL}/surveys`);\n    \n    if (!response.ok) {\n      throw new Error('Failed to fetch surveys');\n    }\n\n    const surveys = await response.json();\n    \n    // Transform backend format to frontend format\n    return surveys.map((survey: any) => ({\n      id: survey.id,\n      name: survey.name,\n      year: survey.year.toString(),\n      type: survey.type,\n      uploadDate: survey.uploadDate,\n      rowCount: survey.rowCount ?? survey.row_count ?? 0,\n      specialtyCount: survey.specialtyCount ?? survey.specialty_count ?? 0,\n      dataPoints: survey.dataPoints ?? survey.data_points ?? 0,\n      colorAccent: survey.colorAccent || '#6366F1',\n      metadata: survey.metadata\n    }));\n  }\n\n  // Get survey data with filters\n  // CRITICAL: Always pass options.limit for large datasets to avoid missing data\n  // See docs/ALLERGY_IMMUNOLOGY_FIX.md for details on the 100-row default limit issue\n  public async getSurveyData(\n    surveyId: string,\n    filters?: {\n      specialty?: string;\n      providerType?: string;\n      region?: string;\n    },\n    options?: { page?: number; limit?: number }\n  ): Promise<{ rows: ISurveyRow[]; pagination?: { page: number; limit: number; total: number; pages: number } }>{\n    const params = new URLSearchParams();\n    if (filters?.specialty) params.append('specialty', filters.specialty);\n    if (filters?.providerType) params.append('providerType', filters.providerType);\n    if (filters?.region) params.append('region', filters.region);\n    if (options?.page) params.append('page', String(options.page));\n    if (options?.limit) params.append('limit', String(options.limit));\n\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/data?${params.toString()}`);\n    \n    if (!response.ok) {\n      throw new Error('Failed to fetch survey data');\n    }\n\n    const data = await response.json();\n    \n    // Transform backend format to frontend format\n    // Backend returns { data: [...], pagination: {...} }\n    const surveyData = data.data || data;\n    // Keep all keys so the grid can render every original column.\n    const rows = surveyData.map((row: any) => ({ ...row }));\n    const pagination = data.pagination\n      ? {\n          page: Number(data.pagination.page) || 1,\n          limit: Number(data.pagination.limit) || rows.length,\n          total: Number(data.pagination.total) || rows.length,\n          pages: Number(data.pagination.pages) || 1,\n        }\n      : undefined;\n    return { rows, pagination };\n  }\n\n  // Get available filters\n  public async getAvailableFiltersForSurvey(surveyId: string): Promise<{\n    specialties: string[];\n    providerTypes: string[];\n    regions: string[];\n  }> {\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/filters`);\n    \n    if (!response.ok) {\n      throw new Error('Failed to fetch filters');\n    }\n\n    return await response.json();\n  }\n\n  // Delete a survey\n  public async deleteSurvey(surveyId: string): Promise<void> {\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}`, {\n      method: 'DELETE',\n    });\n\n    if (!response.ok) {\n      throw new Error('Failed to delete survey');\n    }\n  }\n\n  // Delete all surveys\n  public async deleteAllSurveys(): Promise<void> {\n    const response = await fetch(`${API_BASE_URL}/surveys`, { method: 'DELETE' });\n    if (!response.ok) throw new Error('Failed to delete all surveys');\n  }\n\n  // Export survey data\n  public async exportSurveyData(\n    surveyId: string,\n    format: 'csv' | 'json' = 'csv'\n  ): Promise<Blob> {\n    const response = await fetch(`${API_BASE_URL}/survey/${surveyId}/export?format=${format}`);\n    \n    if (!response.ok) {\n      throw new Error('Failed to export survey data');\n    }\n\n    return await response.blob();\n  }\n\n  // Health check\n  public async healthCheck(): Promise<boolean> {\n    try {\n      const response = await fetch(`${API_BASE_URL}/health`);\n      return response.ok;\n    } catch {\n      return false;\n    }\n  }\n}\n\nexport default BackendService;\n"],"names":["API_BASE_URL","SpecialtyMappingService","constructor","storageService","MAPPINGS_KEY","GROUPS_KEY","LEARNED_MAPPINGS_KEY","specialtyCache","Map","cacheExpiry","CACHE_TTL","SYNONYMS","this","saveMapping","mapping","payload","standardizedName","sourceSpecialties","map","s","specialty","originalName","surveySource","fetch","concat","method","headers","body","JSON","stringify","getAllMappings","res","ok","Error","json","error","console","getUnmappedSpecialties","log","backendService","BackendService","getInstance","surveys","getAllSurveys","length","mappings","unmappedSpecialties","mappedNames","Set","forEach","add","toLowerCase","source","Array","from","batchSize","i","batch","slice","Math","floor","ceil","batchPromises","async","survey","id","rows","getSurveyData","page","limit","counts","row","index","Object","keys","possibleSpecialtyColumns","colName","trim","key","set","get","entries","type","surveyProvider","Promise","all","_ref","count","has","push","name","frequency","autoMapSpecialties","config","unmapped","existingMappings","newMappings","failedMappings","batches","batchIndex","processSpecialtyWithRetry","allSettled","result","_result$reason","status","value","reason","message","warn","maxRetries","attempt","bestMatch","findBestMatch","confidence","confidenceThreshold","find","m","crypto","randomUUID","mappingId","resolve","setTimeout","pow","findSuggestedMatches","calculateConfidence","filter","match","sort","a","b","useFuzzyMatching","arguments","undefined","useSynonyms","maxConfidence","specialtyLower","standardizedLower","getLearnedMapping","then","learnedMapping","includes","synonyms","isSpecialtyMatch","some","syn","isStandardizedMatch","max","similarity","stringSimilarity","sourceLower","sourceSimilarity","saveGroup","group","groups","getAllGroups","existingIndex","findIndex","g","_objectSpread","updatedAt","Date","now","createdAt","storeSurveyData","metadata","totalRows","uniqueSpecialties","uniqueProviderTypes","uniqueRegions","columnMappings","_unused","deleteGroup","groupId","filteredGroups","getMappings","getItem","createMapping","saveLearningData","updateMapping","updates","updatedMapping","deleteMapping","clearAllMappings","setItem","suggestMappings","suggestions","maxSimilarity","standardizedSimilarity","calculateSimilarity","suggestion","str1","str2","createGroup","selectedSpecialties","replace","generateMappingSuggestions","useExistingMappings","normalizeString","str","normalized","normalized1","normalized2","foundMatch","matched","_ref2","_ref3","specialties","totalConfidence","comparisons","j","correctedName","learnedMappings","getLearnedMappings","removeLearnedMapping","instance","getSurveyMeta","surveyId","response","uploadSurvey","file","surveyName","surveyYear","surveyType","onProgress","formData","FormData","append","toString","xhr","XMLHttpRequest","reject","open","onload","parse","responseText","rowCount","err","statusText","onerror","upload","onprogress","event","lengthComputable","percent","round","loaded","total","send","_survey$rowCount","_survey$specialtyCoun","_survey$dataPoints","year","uploadDate","row_count","specialtyCount","specialty_count","dataPoints","data_points","colorAccent","filters","options","params","URLSearchParams","providerType","region","String","data","pagination","Number","pages","getAvailableFiltersForSurvey","deleteSurvey","deleteAllSurveys","exportSurveyData","format","blob","healthCheck"],"sourceRoot":""}